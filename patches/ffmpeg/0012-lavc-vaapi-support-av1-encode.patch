From 55b988ac64a0cafe03c3d766107175555d6faa1a Mon Sep 17 00:00:00 2001
From: Fei Wang <fei.w.wang@intel.com>
Date: Tue, 26 Jan 2021 15:57:33 +0800
Subject: [PATCH 12/13] lavc/vaapi: support av1 encode.

1. Don't enable av1_vaapi_encoder if vaapi is not enabled (Haihao)
2. Support tile groups and levels
3. Use tile_cols_log2/rows instead of tile_cols/rows
4. Follow vp9 to use global_quality as qindex
5. Support CBR (Bug/WA exist, will report to media-driver)
6. Remove va_private_av1.h

Note, if want to enable vaapi av1 encode, need to apply the patch
in libva(not merged) before config ffmpeg:
https://github.com/intel/libva/pull/531/

CQP:
ffmpeg -hwaccel vaapi -vaapi_device /dev/dri/renderD128 -v verbose \
-f rawvideo -pix_fmt nv12 -s:v 320x240 -i 320x240_nv12.yuv         \
-vf 'format=nv12,hwupload' -c:v av1_vaapi -rc_mode CQP             \
-global_quality 33 -i_qfactor 0.8 -i_qoffset 8 -b_qfactor 1.2      \
-b_qoffset 12 -low_power 1 -vframes 10 -y ffmpeg.ivf

CBR:
ffmpeg -hwaccel vaapi -vaapi_device /dev/dri/renderD128 -v verbose \
-f rawvideo -pix_fmt nv12 -s:v 1920x1080 -i input_nv12.yuv         \
-vf 'format=nv12,hwupload' -c:v av1_vaapi -rc_mode CBR -g 30       \
-b:v 2000k -low_power 1 -vframes 13 -y ffmpeg.ivf

Signed-off-by: Fei Wang <fei.w.wang@intel.com>
Signed-off-by: Haihao Xiang <haihao.xiang@intel.com>
---
 configure                            |   3 +
 libavcodec/Makefile                  |   2 +
 libavcodec/allcodecs.c               |   1 +
 libavcodec/av1.h                     |   7 +
 libavcodec/av1_profile_level.c       |  92 ++++
 libavcodec/av1_profile_level.h       |  58 +++
 libavcodec/cbs_av1.c                 |   5 +-
 libavcodec/cbs_av1.h                 |   8 +
 libavcodec/cbs_av1_syntax_template.c |  31 ++
 libavcodec/tests/.gitignore          |   1 +
 libavcodec/tests/av1_levels.c        | 124 ++++++
 libavcodec/vaapi_encode.c            | 175 ++++++--
 libavcodec/vaapi_encode.h            |  19 +
 libavcodec/vaapi_encode_av1.c        | 813 +++++++++++++++++++++++++++++++++++
 tests/fate/libavcodec.mak            |   5 +
 15 files changed, 1316 insertions(+), 28 deletions(-)
 create mode 100644 libavcodec/av1_profile_level.c
 create mode 100644 libavcodec/av1_profile_level.h
 create mode 100644 libavcodec/tests/av1_levels.c
 create mode 100644 libavcodec/vaapi_encode_av1.c

diff --git a/configure b/configure
index 4a0d7b7..3e6a556 100755
--- a/configure
+++ b/configure
@@ -3193,6 +3193,8 @@ wmv3_crystalhd_decoder_select="crystalhd"
 av1_qsv_decoder_select="qsvdec"
 av1_qsv_encoder_select="qsvenc"
 av1_qsv_encoder_deps="libvpl MFX_EXTBUFF_AV1_BITSTREAM_PARAM"
+av1_vaapi_encoder_deps="VAEncPictureParameterBufferAV1"
+av1_vaapi_encoder_select="cbs_av1 vaapi_encode"
 
 # parsers
 aac_parser_select="adts_header"
@@ -6791,6 +6793,7 @@ if enabled vaapi; then
     check_type "va/va.h va/va_enc_jpeg.h" "VAEncPictureParameterBufferJPEG"
     check_type "va/va.h va/va_enc_vp8.h"  "VAEncPictureParameterBufferVP8"
     check_type "va/va.h va/va_enc_vp9.h"  "VAEncPictureParameterBufferVP9"
+    check_type "va/va.h va/va_enc_av1.h"  "VAEncPictureParameterBufferAV1"
 fi
 
 if enabled_all opencl libdrm ; then
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index d9287e1..aa01525 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -232,6 +232,7 @@ OBJS-$(CONFIG_AV1_CUVID_DECODER)       += cuviddec.o
 OBJS-$(CONFIG_AV1_QSV_DECODER)         += qsvdec.o
 OBJS-$(CONFIG_AV1_QSV_ENCODER)         += qsvenc_av1.o
 OBJS-$(CONFIG_AVRN_DECODER)            += avrndec.o
+OBJS-$(CONFIG_AV1_VAAPI_ENCODER)       += vaapi_encode_av1.o av1_profile_level.o
 OBJS-$(CONFIG_AVRP_DECODER)            += r210dec.o
 OBJS-$(CONFIG_AVRP_ENCODER)            += r210enc.o
 OBJS-$(CONFIG_AVS_DECODER)             += avs.o
@@ -1232,6 +1233,7 @@ TESTPROGS-$(CONFIG_H264_METADATA_BSF)     += h264_levels
 TESTPROGS-$(CONFIG_HEVC_METADATA_BSF)     += h265_levels
 TESTPROGS-$(CONFIG_RANGECODER)            += rangecoder
 TESTPROGS-$(CONFIG_SNOW_ENCODER)          += snowenc
+TESTPROGS-$(CONFIG_AV1_VAAPI_ENCODER)     += av1_levels
 
 TESTOBJS = dctref.o
 
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index a7555e1..2746e62 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -801,6 +801,7 @@ extern const AVCodec ff_av1_decoder;
 extern const AVCodec ff_av1_cuvid_decoder;
 extern const AVCodec ff_av1_qsv_decoder;
 extern const AVCodec ff_av1_qsv_encoder;
+extern const AVCodec ff_av1_vaapi_encoder;
 extern const AVCodec ff_libopenh264_encoder;
 extern const AVCodec ff_libopenh264_decoder;
 extern const AVCodec ff_h264_amf_encoder;
diff --git a/libavcodec/av1.h b/libavcodec/av1.h
index 0f99ae4..61b93d3 100644
--- a/libavcodec/av1.h
+++ b/libavcodec/av1.h
@@ -168,4 +168,11 @@ enum {
     AV1_RESTORE_SWITCHABLE = 3,
 };
 
+// TX mode (section 6.8.21)
+enum {
+    AV1_ONLY_4X4       = 0,
+    AV1_TX_MODE_LARGEST     = 1,
+    AV1_TX_MODE_SELECT    = 2,
+};
+
 #endif /* AVCODEC_AV1_H */
diff --git a/libavcodec/av1_profile_level.c b/libavcodec/av1_profile_level.c
new file mode 100644
index 0000000..299ff18
--- /dev/null
+++ b/libavcodec/av1_profile_level.c
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2021 Fei Wang
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/common.h"
+#include "av1_profile_level.h"
+
+/** ignore entries which named in spec but no details. Like level 2.2 and 7.0. */
+static const AV1LevelDescriptor av1_levels[] = {
+    // Name                      MaxVSize                           MainMbps              MaxTiles
+    // |  level_idx                 | MaxDisplayRate                    | HighMbps         | MaxTileCols
+    // |      |   MaxPicSize        |       |     MaxDecodeRate         |    |   MainCR    |   |
+    // |      |     |    MaxHSize   |       |           | MaxHeaderRate |    |     | HighCR|   |
+    // |      |     |        |      |       |           |       |       |    |     |  |    |   |
+    { "2.0",  0,   147456,  2048, 1152,   4423680,     5529600, 150,   1.5,     0, 2, 0,   8,  4 },
+    { "2.1",  1,   278784,  2816, 1584,   8363520,    10454400, 150,   3.0,     0, 2, 0,   8,  4 },
+    { "3.0",  4,   665856,  4352, 2448,  19975680,    24969600, 150,   6.0,     0, 2, 0,  16,  6 },
+    { "3.1",  5,  1065024,  5504, 3096,  31950720,    39938400, 150,  10.0,     0, 2, 0,  16,  6 },
+    { "4.0",  8,  2359296,  6144, 3456,  70778880,    77856768, 300,  12.0,  30.0, 4, 4,  32,  8 },
+    { "4.1",  9,  2359296,  6144, 3456,  141557760,  155713536, 300,  20.0,  50.0, 4, 4,  32,  8 },
+    { "5.0", 12,  8912896,  8192, 4352,  267386880,  273715200, 300,  30.0, 100.0, 6, 4,  64,  8 },
+    { "5.1", 13,  8912896,  8192, 4352,  534773760,  547430400, 300,  40.0, 160.0, 8, 4,  64,  8 },
+    { "5.2", 14,  8912896,  8192, 4352, 1069547520, 1094860800, 300,  60.0, 240.0, 8, 4,  64,  8 },
+    { "5.3", 15,  8912896,  8192, 4352, 1069547520, 1176502272, 300,  60.0, 240.0, 8, 4,  64,  8 },
+    { "6.0", 16, 35651584, 16384, 8704, 1069547520, 1176502272, 300,  60.0, 240.0, 8, 4, 128, 16 },
+    { "6.1", 17, 35651584, 16384, 8704, 2139095040, 2189721600, 300, 100.0, 480.0, 8, 4, 128, 16 },
+    { "6.2", 18, 35651584, 16384, 8704, 4278190080, 4379443200, 300, 160.0, 800.0, 8, 4, 128, 16 },
+    { "6.3", 19, 35651584, 16384, 8704, 4278190080, 4706009088, 300, 160.0, 800.0, 8, 4, 128, 16 },
+};
+
+const AV1LevelDescriptor *ff_av1_guess_level(int64_t bitrate,
+                                             int tier,
+                                             int width,
+                                             int height,
+                                             int tiles,
+                                             int tile_cols,
+                                             float fps)
+{
+    int pic_size;
+    uint64_t display_rate;
+    float max_br;
+    int i;
+
+    pic_size = width * height;
+    display_rate = (uint64_t)pic_size * fps;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(av1_levels); i++) {
+        const AV1LevelDescriptor *level = &av1_levels[i];
+        // Limitation: decode rate, header rate, compress rate, etc. are not considered.
+        if (pic_size > level->max_pic_size)
+            continue;
+        if (width > level->max_h_size)
+            continue;
+        if (height > level->max_v_size)
+            continue;
+        if (display_rate > level->max_display_rate)
+            continue;
+
+        if (tier)
+            max_br = level->high_mbps;
+        else
+            max_br = level->main_mbps;
+        if (!max_br)
+            continue;
+        if (bitrate > (int64_t)(1000000.0 * max_br))
+            continue;
+
+        if (tiles > level->max_tiles)
+            continue;
+        if (tile_cols > level->max_tile_cols)
+            continue;
+        return level;
+    }
+
+    return NULL;
+}
diff --git a/libavcodec/av1_profile_level.h b/libavcodec/av1_profile_level.h
new file mode 100644
index 0000000..9a6ea94
--- /dev/null
+++ b/libavcodec/av1_profile_level.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2021 Fei Wang
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_AV1_PROFILE_LEVEL_H
+#define AVCODEC_AV1_PROFILE_LEVEL_H
+
+#include <stdint.h>
+
+typedef struct AV1LevelDescriptor {
+    const char *name;
+    uint8_t     level_idx;
+
+    uint32_t    max_pic_size;
+    uint32_t    max_h_size;
+    uint32_t    max_v_size;
+    uint64_t    max_display_rate;
+    uint64_t    max_decode_rate;
+
+    uint32_t    max_header_rate;
+    float       main_mbps;
+    float       high_mbps;
+    uint32_t    main_cr;
+    uint32_t    high_cr;
+    uint32_t    max_tiles;
+    uint32_t    max_tile_cols;
+} AV1LevelDescriptor;
+
+/**
+ * Guess the level of a stream from some parameters.
+ *
+ * Unknown parameters may be zero, in which case they are ignored.
+ */
+const AV1LevelDescriptor *ff_av1_guess_level(int64_t bitrate,
+                                             int tier,
+                                             int width,
+                                             int height,
+                                             int tile_rows,
+                                             int tile_cols,
+                                             float fps);
+
+#endif /* AVCODEC_AV1_PROFILE_LEVEL_H */
diff --git a/libavcodec/cbs_av1.c b/libavcodec/cbs_av1.c
index 302e1f3..6e639a6 100644
--- a/libavcodec/cbs_av1.c
+++ b/libavcodec/cbs_av1.c
@@ -1196,6 +1196,9 @@ static int cbs_av1_write_obu(CodedBitstreamContext *ctx,
     flush_put_bits(pbc);
     av_assert0(data_pos <= start_pos);
 
+    if (obu->header.obu_type == AV1_OBU_FRAME_HEADER)
+        priv->frame_header_data_offset = data_pos * 8;
+
     if (8 * obu->obu_size > put_bits_left(pbc))
         return AVERROR(ENOSPC);
 
@@ -1204,7 +1207,7 @@ static int cbs_av1_write_obu(CodedBitstreamContext *ctx,
                 pbc->buf + start_pos, header_size);
         skip_put_bytes(pbc, header_size);
 
-        if (td) {
+        if (td && td->data) {
             memcpy(pbc->buf + data_pos + header_size,
                    td->data, td->data_size);
             skip_put_bytes(pbc, td->data_size);
diff --git a/libavcodec/cbs_av1.h b/libavcodec/cbs_av1.h
index 1fc80dc..b13f0fd 100644
--- a/libavcodec/cbs_av1.h
+++ b/libavcodec/cbs_av1.h
@@ -435,6 +435,14 @@ typedef struct CodedBitstreamAV1Context {
     uint8_t     *frame_header;
     size_t       frame_header_size;
 
+    int frame_header_start_position;
+    int frame_header_data_offset;
+    int qindex_offset;
+    int segmentation_offset;
+    int loopfilter_offset;
+    int cdef_start_offset;
+    int cdef_end_offset;
+
     int temporal_id;
     int spatial_id;
     int operating_point_idc;
diff --git a/libavcodec/cbs_av1_syntax_template.c b/libavcodec/cbs_av1_syntax_template.c
index 6fe6e9a..b43683b 100644
--- a/libavcodec/cbs_av1_syntax_template.c
+++ b/libavcodec/cbs_av1_syntax_template.c
@@ -700,6 +700,12 @@ static int FUNC(quantization_params)(CodedBitstreamContext *ctx, RWContext *rw,
     const AV1RawSequenceHeader *seq = priv->sequence_header;
     int err;
 
+#ifdef READ
+    priv->qindex_offset = get_bits_count(rw);
+#else
+    priv->qindex_offset = put_bits_count(rw);
+#endif
+
     fb(8, base_q_idx);
 
     delta_q(delta_q_y_dc);
@@ -750,6 +756,12 @@ static int FUNC(segmentation_params)(CodedBitstreamContext *ctx, RWContext *rw,
     static const int16_t default_feature_value[AV1_SEG_LVL_MAX] = { 0 };
     int i, j, err;
 
+#ifdef READ
+    priv->segmentation_offset = get_bits_count(rw);
+#else
+    priv->segmentation_offset = put_bits_count(rw);
+#endif
+
     flag(segmentation_enabled);
 
     if (current->segmentation_enabled) {
@@ -877,6 +889,12 @@ static int FUNC(loop_filter_params)(CodedBitstreamContext *ctx, RWContext *rw,
         return 0;
     }
 
+#ifdef READ
+    priv->loopfilter_offset = get_bits_count(rw);
+#else
+    priv->loopfilter_offset = put_bits_count(rw);
+#endif
+
     fb(6, loop_filter_level[0]);
     fb(6, loop_filter_level[1]);
 
@@ -954,6 +972,12 @@ static int FUNC(cdef_params)(CodedBitstreamContext *ctx, RWContext *rw,
         return 0;
     }
 
+#ifdef READ
+    priv->cdef_start_offset = get_bits_count(rw);
+#else
+    priv->cdef_start_offset = put_bits_count(rw);
+#endif
+
     fb(2, cdef_damping_minus_3);
     fb(2, cdef_bits);
 
@@ -967,6 +991,12 @@ static int FUNC(cdef_params)(CodedBitstreamContext *ctx, RWContext *rw,
         }
     }
 
+#ifdef READ
+    priv->cdef_end_offset = get_bits_count(rw);
+#else
+    priv->cdef_end_offset = put_bits_count(rw);
+#endif
+
     return 0;
 }
 
@@ -1721,6 +1751,7 @@ static int FUNC(frame_header_obu)(CodedBitstreamContext *ctx, RWContext *rw,
         start_pos = put_bits_count(rw);
 #endif
 
+        priv->frame_header_start_position = start_pos;
         CHECK(FUNC(uncompressed_header)(ctx, rw, current));
 
         priv->tile_num = 0;
diff --git a/libavcodec/tests/.gitignore b/libavcodec/tests/.gitignore
index 69bf891..20d378f 100644
--- a/libavcodec/tests/.gitignore
+++ b/libavcodec/tests/.gitignore
@@ -1,3 +1,4 @@
+/av1_levels
 /avfft
 /avpacket
 /cabac
diff --git a/libavcodec/tests/av1_levels.c b/libavcodec/tests/av1_levels.c
new file mode 100644
index 0000000..81c2bec
--- /dev/null
+++ b/libavcodec/tests/av1_levels.c
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2021 Fei Wang
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/common.h"
+#include "libavcodec/av1_profile_level.h"
+
+static const struct {
+    int width;
+    int height;
+    float framerate;
+    int level_idx;
+} test_sizes[] = {
+    {  426,  240,  30.0,  0 },
+    {  640,  360,  30.0,  1 },
+    {  854,  480,  30.0,  4 },
+    { 1280,  720,  30.0,  5 },
+    { 1920, 1080,  30.0,  8 },
+    { 1920, 1080,  60.0,  9 },
+    { 3840, 2160,  30.0, 12 },
+    { 3840, 2160,  60.0, 13 },
+    { 3840, 2160, 120.0, 14 },
+    { 7680, 4320,  30.0, 16 },
+    { 7680, 4320,  60.0, 17 },
+    { 7680, 4320, 120.0, 18 },
+};
+
+static const struct {
+    int64_t bitrate;
+    int tier;
+    int level_idx;
+} test_bitrate[] = {
+    {   1500000, 0,  0 },
+    {   3000000, 0,  1 },
+    {   6000000, 0,  4 },
+    {  10000000, 0,  5 },
+    {  12000000, 0,  8 },
+    {  30000000, 1,  8 },
+    {  20000000, 0,  9 },
+    {  50000000, 1,  9 },
+    {  30000000, 0, 12 },
+    { 100000000, 1, 12 },
+    {  40000000, 0, 13 },
+    { 160000000, 1, 13 },
+    {  60000000, 0, 14 },
+    { 240000000, 1, 14 },
+    { 100000000, 0, 17 },
+    { 480000000, 1, 17 },
+    { 160000000, 0, 18 },
+    { 800000000, 1, 18 },
+};
+
+static const struct {
+    int tiles;
+    int tile_cols;
+    int level_idx;
+} test_tiles[] = {
+    {    8,  4,  0 },
+    {   16,  6,  4 },
+    {   32,  8,  8 },
+    {   64,  8, 12 },
+    {  128, 16, 16 },
+};
+
+int main(void)
+{
+    const AV1LevelDescriptor *level;
+    int i;
+
+#define CHECK(expected, format, ...) do { \
+        if (level ? (level->level_idx != expected) \
+                     : !level) { \
+            av_log(NULL, AV_LOG_ERROR, "Incorrect level for " \
+                   format ": expected %d, got %d.\n", __VA_ARGS__, \
+                   expected, level ? level->level_idx : -1); \
+            return 1; \
+        } \
+    } while (0)
+
+    for (i = 0; i < FF_ARRAY_ELEMS(test_sizes); i++) {
+        level = ff_av1_guess_level(0, 0,
+                                   test_sizes[i].width,
+                                   test_sizes[i].height,
+                                   0, 0, test_sizes[i].framerate);
+        CHECK(test_sizes[i].level_idx, "size %dx%d, framerate %f",
+              test_sizes[i].width, test_sizes[i].height, test_sizes[i].framerate);
+    }
+
+    for (i = 0; i < FF_ARRAY_ELEMS(test_bitrate); i++) {
+        level = ff_av1_guess_level(test_bitrate[i].bitrate,
+                                   test_bitrate[i].tier,
+                                   0, 0, 0, 0, 0);
+        CHECK(test_bitrate[i].level_idx, "bitrate %"PRId64" tier %d",
+              test_bitrate[i].bitrate, test_bitrate[i].tier);
+    }
+
+    for (i = 0; i < FF_ARRAY_ELEMS(test_tiles); i++) {
+        level = ff_av1_guess_level(0, 0, 0, 0,
+                                   test_tiles[i].tiles,
+                                   test_tiles[i].tile_cols,
+                                   0);
+        CHECK(test_tiles[i].level_idx, "tiles %d, tile cols %d",
+              test_tiles[i].tiles,
+              test_tiles[i].tile_cols);
+    }
+
+    return 0;
+}
diff --git a/libavcodec/vaapi_encode.c b/libavcodec/vaapi_encode.c
index ec054ae..64b9086 100644
--- a/libavcodec/vaapi_encode.c
+++ b/libavcodec/vaapi_encode.c
@@ -314,6 +314,15 @@ static int vaapi_encode_issue(AVCodecContext *avctx,
 
     pic->nb_param_buffers = 0;
 
+    if ((avctx->codec_id == AV_CODEC_ID_AV1) && (pic->type == PICTURE_TYPE_B)
+        && (pic->next->type == PICTURE_TYPE_P)) {
+        pic->tail_data = av_mallocz(MAX_PARAM_BUFFER_SIZE);
+        if (!pic->tail_data) {
+            err = AVERROR(ENOMEM);
+            goto fail;
+        }
+    }
+
     if (pic->type == PICTURE_TYPE_IDR && ctx->codec->init_sequence_params) {
         err = vaapi_encode_make_param_buffer(avctx, pic,
                                              VAEncSequenceParameterBufferType,
@@ -617,22 +626,66 @@ fail_at_end:
     av_freep(&pic->param_buffers);
     av_freep(&pic->slices);
     av_freep(&pic->roi);
+    av_freep(&pic->tail_data);
     av_frame_free(&pic->recon_image);
     av_buffer_unref(&pic->output_buffer_ref);
     pic->output_buffer = VA_INVALID_ID;
     return err;
 }
 
+static int vaapi_encode_set_pkt_timestamp(AVCodecContext *avctx, VAAPIEncodePicture *pic, AVPacket *pkt)
+{
+    VAAPIEncodeContext *ctx = avctx->priv_data;
+
+    if (avctx->codec_id == AV_CODEC_ID_AV1) {
+        pkt->dts = pkt->pts = ctx->first_pts + ctx->av1_pts_diff;
+        if (pkt->size)
+            ctx->av1_pts_diff++;
+
+        goto end;
+    }
+
+    if (ctx->output_delay == 0) {
+        pkt->dts = pkt->pts;
+    } else if (pic->encode_order < ctx->decode_delay) {
+        if (ctx->ts_ring[pic->encode_order] < INT64_MIN + ctx->dts_pts_diff)
+            pkt->dts = INT64_MIN;
+        else
+            pkt->dts = ctx->ts_ring[pic->encode_order] - ctx->dts_pts_diff;
+    } else {
+        pkt->dts = ctx->ts_ring[(pic->encode_order - ctx->decode_delay) %
+                                (3 * ctx->output_delay)];
+    }
+
+end:
+    av_log(avctx, AV_LOG_DEBUG, "Output packet: size %u bytes, pts %"PRId64", dts %"PRId64".\n",
+           pkt->size, pkt->pts, pkt->dts);
+    return 0;
+}
+
 static int vaapi_encode_output(AVCodecContext *avctx,
                                VAAPIEncodePicture *pic, AVPacket *pkt)
 {
     VAAPIEncodeContext *ctx = avctx->priv_data;
     VACodedBufferSegment *buf_list, *buf;
     VAStatus vas;
-    int total_size = 0;
+    int total_size = 0, pkt_size = 0;
     uint8_t *ptr;
     int err;
 
+    if (!pic) {
+        pkt_size =  ctx->coded_frame_size;
+        err = ff_get_encode_buffer(avctx, pkt, pkt_size, 0);
+        if (err < 0)
+            goto fail_mapped;
+        ptr = pkt->data;
+        memcpy(ptr, ctx->coded_frame_data, ctx->coded_frame_size);
+        ctx->coded_frame_type = CODED_FRAME_NONE;
+        vaapi_encode_set_pkt_timestamp(avctx, pic, pkt);
+
+        return 0;
+    }
+
     err = vaapi_encode_wait(avctx, pic);
     if (err < 0)
         return err;
@@ -650,11 +703,48 @@ static int vaapi_encode_output(AVCodecContext *avctx,
     for (buf = buf_list; buf; buf = buf->next)
         total_size += buf->size;
 
-    err = ff_get_encode_buffer(avctx, pkt, total_size, 0);
-    ptr = pkt->data;
+    if (ctx->coded_frame_type == CODED_FRAME_MERGE_TO_NEXT) {
+        pkt_size = total_size + ctx->coded_frame_size;
+        err = ff_get_encode_buffer(avctx, pkt, pkt_size, 0);
+        if (err < 0)
+            goto fail_mapped;
+        ptr = pkt->data;
+        memcpy(ptr, ctx->coded_frame_data, ctx->coded_frame_size);
+        ptr += ctx->coded_frame_size;
+        ctx->coded_frame_type = CODED_FRAME_NONE;
+    } else if (ctx->coded_frame_type == CODED_FRAME_COMPLETED) {
+        pkt_size = ctx->coded_frame_size;
+        err = ff_get_encode_buffer(avctx, pkt, pkt_size, 0);
+        if (err < 0)
+            goto fail_mapped;
+        ptr = pkt->data;
+        memcpy(ptr, ctx->coded_frame_data, ctx->coded_frame_size);
+        ctx->coded_frame_data = av_realloc(ctx->coded_frame_data, total_size);
+        if (!ctx->coded_frame_data)
+            return AVERROR(ENOMEM);
+        ptr = ctx->coded_frame_data;
+        ctx->coded_frame_size = total_size;
+        ctx->coded_frame_type = pic->cache_coded_frame ? CODED_FRAME_MERGE_TO_NEXT : CODED_FRAME_COMPLETED;
+    } else {
+        if (!pic->cache_coded_frame) {
+            pkt_size = total_size;
+            err = ff_get_encode_buffer(avctx, pkt, pkt_size, 0);
+            if (err < 0)
+                goto fail_mapped;
+            ptr = pkt->data;
+        } else {
+            ctx->coded_frame_data = av_realloc(ctx->coded_frame_data, total_size);
+            if (!ctx->coded_frame_data)
+                return AVERROR(ENOMEM);
+            ptr = ctx->coded_frame_data;
+            ctx->coded_frame_type = CODED_FRAME_MERGE_TO_NEXT;
+            ctx->coded_frame_size = total_size;
+        }
+    }
 
-    if (err < 0)
-        goto fail_mapped;
+    if (pic->type == PICTURE_TYPE_IDR)
+        pkt->flags |= AV_PKT_FLAG_KEY;
+    pkt->pts = pic->pts;
 
     for (buf = buf_list; buf; buf = buf->next) {
         av_log(avctx, AV_LOG_DEBUG, "Output buffer: %u bytes "
@@ -664,11 +754,6 @@ static int vaapi_encode_output(AVCodecContext *avctx,
         ptr += buf->size;
     }
 
-    if (pic->type == PICTURE_TYPE_IDR)
-        pkt->flags |= AV_PKT_FLAG_KEY;
-
-    pkt->pts = pic->pts;
-
     vas = vaUnmapBuffer(ctx->hwctx->display, pic->output_buffer);
     if (vas != VA_STATUS_SUCCESS) {
         av_log(avctx, AV_LOG_ERROR, "Failed to unmap output buffers: "
@@ -682,6 +767,24 @@ static int vaapi_encode_output(AVCodecContext *avctx,
 
     av_log(avctx, AV_LOG_DEBUG, "Output read for pic %"PRId64"/%"PRId64".\n",
            pic->display_order, pic->encode_order);
+
+    if (pic->tail_size) {
+        if (ctx->coded_frame_type) {
+            av_log(avctx, AV_LOG_ERROR, "Fail to cache data because cached frame data is not NULL.\n");
+            err = AVERROR_BUG;
+            goto fail;
+        }
+        ctx->coded_frame_data = av_realloc(ctx->coded_frame_data, pic->tail_size);
+        if (!ctx->coded_frame_data)
+            return AVERROR(ENOMEM);
+        memcpy(ctx->coded_frame_data, pic->tail_data, pic->tail_size);
+        ctx->coded_frame_type = CODED_FRAME_COMPLETED;
+        ctx->coded_frame_size = pic->tail_size;
+    }
+
+    if (!pkt->size && pic->cache_coded_frame)
+        return AVERROR(EAGAIN);
+
     return 0;
 
 fail_mapped:
@@ -758,12 +861,33 @@ static int vaapi_encode_free(AVCodecContext *avctx,
     av_freep(&pic->priv_data);
     av_freep(&pic->codec_picture_params);
     av_freep(&pic->roi);
-
+    av_freep(&pic->tail_data);
     av_free(pic);
 
     return 0;
 }
 
+int ff_vaapi_encode_get_attributs(AVCodecContext *avctx, VAConfigAttrib *attr)
+{
+    VAAPIEncodeContext *ctx = avctx->priv_data;
+    VAStatus vas;
+
+    vas = vaGetConfigAttributes(ctx->hwctx->display,
+                                ctx->va_profile,
+                                ctx->va_entrypoint,
+                                attr, 1);
+    if (vas != VA_STATUS_SUCCESS) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to query "
+               "config attribute: %d (%s).\n", vas, vaErrorStr(vas));
+        return AVERROR_EXTERNAL;
+    }
+    if (attr->value == VA_ATTRIB_NOT_SUPPORTED)
+        av_log(avctx, AV_LOG_WARNING, "attribute type:%d is not "
+               "supported.\n", attr->type);
+
+    return 0;
+}
+
 static void vaapi_encode_add_ref(AVCodecContext *avctx,
                                  VAAPIEncodePicture *pic,
                                  VAAPIEncodePicture *target,
@@ -1179,8 +1303,16 @@ int ff_vaapi_encode_receive_packet(AVCodecContext *avctx, AVPacket *pkt)
 
     pic = NULL;
     err = vaapi_encode_pick_next(avctx, &pic);
-    if (err < 0)
+    if (err < 0 && err != AVERROR_EOF)
         return err;
+
+    if (!pic) {
+        if (ctx->coded_frame_type)
+            return  vaapi_encode_output(avctx, pic, pkt);
+        else
+            return AVERROR_EOF;
+    }
+
     av_assert0(pic);
 
     pic->encode_order = ctx->encode_order++;
@@ -1192,29 +1324,17 @@ int ff_vaapi_encode_receive_packet(AVCodecContext *avctx, AVPacket *pkt)
     }
 
     err = vaapi_encode_output(avctx, pic, pkt);
-    if (err < 0) {
+    if (err < 0 && err != AVERROR(EAGAIN)) {
         av_log(avctx, AV_LOG_ERROR, "Output failed: %d.\n", err);
         return err;
     }
 
-    if (ctx->output_delay == 0) {
-        pkt->dts = pkt->pts;
-    } else if (pic->encode_order < ctx->decode_delay) {
-        if (ctx->ts_ring[pic->encode_order] < INT64_MIN + ctx->dts_pts_diff)
-            pkt->dts = INT64_MIN;
-        else
-            pkt->dts = ctx->ts_ring[pic->encode_order] - ctx->dts_pts_diff;
-    } else {
-        pkt->dts = ctx->ts_ring[(pic->encode_order - ctx->decode_delay) %
-                                (3 * ctx->output_delay)];
-    }
-    av_log(avctx, AV_LOG_DEBUG, "Output packet: pts %"PRId64" dts %"PRId64".\n",
-           pkt->pts, pkt->dts);
+    vaapi_encode_set_pkt_timestamp(avctx, pic, pkt);
 
     ctx->output_order = pic->encode_order;
     vaapi_encode_clear_old(avctx);
 
-    return 0;
+    return err;
 }
 
 
@@ -2552,6 +2672,7 @@ av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)
 
     av_freep(&ctx->codec_sequence_params);
     av_freep(&ctx->codec_picture_params);
+    av_freep(&ctx->coded_frame_data);
 
     av_buffer_unref(&ctx->recon_frames_ref);
     av_buffer_unref(&ctx->input_frames_ref);
diff --git a/libavcodec/vaapi_encode.h b/libavcodec/vaapi_encode.h
index b41604a..35af933 100644
--- a/libavcodec/vaapi_encode.h
+++ b/libavcodec/vaapi_encode.h
@@ -125,6 +125,12 @@ typedef struct VAAPIEncodePicture {
 
     int          nb_slices;
     VAAPIEncodeSlice *slices;
+
+    /** flag to indicate if the coded frame data need to be cached. */
+    int cache_coded_frame;
+
+    void *tail_data;
+    size_t tail_size;
 } VAAPIEncodePicture;
 
 typedef struct VAAPIEncodeProfile {
@@ -153,6 +159,12 @@ enum {
     RC_MODE_MAX = RC_MODE_AVBR,
 };
 
+enum {
+    CODED_FRAME_NONE,
+    CODED_FRAME_COMPLETED,
+    CODED_FRAME_MERGE_TO_NEXT,
+};
+
 typedef struct VAAPIEncodeRCMode {
     // Mode from above enum (RC_MODE_*).
     int mode;
@@ -296,6 +308,7 @@ typedef struct VAAPIEncodeContext {
 
     // Timestamp handling.
     int64_t         first_pts;
+    int64_t         av1_pts_diff;
     int64_t         dts_pts_diff;
     int64_t         ts_ring[MAX_REORDER_DELAY * 3];
 
@@ -344,6 +357,11 @@ typedef struct VAAPIEncodeContext {
     // encounter a frame with ROI side data.
     int             roi_warned;
 
+    /** coded frame data need to deal with next frame's data */
+    void  *coded_frame_data;
+    size_t coded_frame_size;
+    int    coded_frame_type;
+
     AVFrame         *frame;
 } VAAPIEncodeContext;
 
@@ -441,6 +459,7 @@ int ff_vaapi_encode_receive_packet(AVCodecContext *avctx, AVPacket *pkt);
 int ff_vaapi_encode_init(AVCodecContext *avctx);
 int ff_vaapi_encode_close(AVCodecContext *avctx);
 
+int ff_vaapi_encode_get_attributs(AVCodecContext *avctx, VAConfigAttrib *attr);
 
 #define VAAPI_ENCODE_COMMON_OPTIONS \
     { "low_power", \
diff --git a/libavcodec/vaapi_encode_av1.c b/libavcodec/vaapi_encode_av1.c
new file mode 100644
index 0000000..8146515
--- /dev/null
+++ b/libavcodec/vaapi_encode_av1.c
@@ -0,0 +1,813 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <va/va.h>
+#include <va/va_enc_av1.h>
+
+#include "libavutil/pixdesc.h"
+#include "libavutil/avassert.h"
+#include "libavutil/opt.h"
+#include "internal.h"
+#include "av1_profile_level.h"
+#include "cbs.h"
+#include "cbs_av1.h"
+#include "av1.h"
+#include "vaapi_encode.h"
+
+#define AV1_MAX_QUANT 255
+
+typedef struct VAAPIEncodeAV1Picture {
+    int64_t last_idr_frame;
+    int slot;
+} VAAPIEncodeAV1Picture;
+
+typedef struct VAAPIEncodeAV1Context {
+    VAAPIEncodeContext common;
+    AV1RawOBU sh; /**< sequence header.*/
+    AV1RawOBU fh; /**< frame header.*/
+    CodedBitstreamContext *cbc;
+    CodedBitstreamFragment current_obu;
+    VAConfigAttribValEncAV1 attr;
+    VAConfigAttribValEncAV1Ext1 attr_ext1;
+    VAConfigAttribValEncAV1Ext2 attr_ext2;
+
+    char sh_data[MAX_PARAM_BUFFER_SIZE]; /**< coded sequence header data. */
+    size_t sh_data_len; /**< bit length of sh_data. */
+    char fh_data[MAX_PARAM_BUFFER_SIZE]; /**< coded frame header data. */
+    size_t fh_data_len; /**< bit length of fh_data. */
+
+    int enable_128x128_superblock;
+    int sb_cols;
+    int sb_rows;
+    int tile_cols;
+    int tile_rows;
+    int tile_width_sb;
+    int tile_height_sb;
+
+    int q_idx_idr;
+    int q_idx_p;
+    int q_idx_b;
+
+    /** user options */
+    int level;
+    int tier;
+    int tile_cols_log2;
+    int tile_rows_log2;
+    int tile_groups;
+} VAAPIEncodeAV1Context;
+
+static av_cold int vaapi_encode_av1_configure(AVCodecContext *avctx)
+{
+    VAAPIEncodeContext     *ctx = avctx->priv_data;
+    VAAPIEncodeAV1Context *priv = avctx->priv_data;
+    int ret;
+    ret = ff_cbs_init(&priv->cbc, AV_CODEC_ID_AV1, avctx);
+    if (ret < 0)
+        return ret;
+
+    if (ctx->rc_mode->quality) {
+        priv->q_idx_p = av_clip(ctx->rc_quality, 0, AV1_MAX_QUANT);
+        if (avctx->i_quant_factor > 0.0)
+            priv->q_idx_idr =
+                av_clip((avctx->i_quant_factor * priv->q_idx_p  +
+                         avctx->i_quant_offset) + 0.5,
+                        0, AV1_MAX_QUANT);
+        else
+            priv->q_idx_idr = priv->q_idx_p;
+
+        if (avctx->b_quant_factor > 0.0)
+            priv->q_idx_b =
+                av_clip((avctx->b_quant_factor * priv->q_idx_p  +
+                         avctx->b_quant_offset) + 0.5,
+                        0, AV1_MAX_QUANT);
+        else
+            priv->q_idx_b = priv->q_idx_p;
+    } else {
+        // Arbitrary value.
+        priv->q_idx_idr = priv->q_idx_p = priv->q_idx_b = 128;
+    }
+
+    return 0;
+}
+
+static int vaapi_encode_av1_add_obu(AVCodecContext *avctx,
+                                    CodedBitstreamFragment *au,
+                                    uint8_t type,
+                                    void *obu_unit)
+{
+    int ret;
+
+    ret = ff_cbs_insert_unit_content(au, -1,
+                                     type, obu_unit, NULL);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to add OBU unit: "
+               "type = %d.\n", type);
+        return ret;
+    }
+
+    return 0;
+}
+
+static int vaapi_encode_av1_write_obu(AVCodecContext *avctx,
+                                      char *data, size_t *data_len,
+                                      CodedBitstreamFragment *au)
+{
+    VAAPIEncodeAV1Context *priv = avctx->priv_data;
+    int ret;
+
+    ret = ff_cbs_write_fragment_data(priv->cbc, au);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to write packed header.\n");
+        return ret;
+    }
+
+    if ((size_t)8 * MAX_PARAM_BUFFER_SIZE < 8 * au->data_size - au->data_bit_padding) {
+        av_log(avctx, AV_LOG_ERROR, "Access unit too large: "
+               "%zu < %zu.\n", (size_t)8 * MAX_PARAM_BUFFER_SIZE,
+               8 * au->data_size - au->data_bit_padding);
+        return AVERROR(ENOSPC);
+    }
+
+    memcpy(data, au->data, au->data_size);
+    *data_len = 8 * au->data_size - au->data_bit_padding;
+
+    return 0;
+}
+
+static int tile_log2(int blkSize, int target) {
+    int k;
+    for (k = 0; (blkSize << k) < target; k++);
+    return k;
+}
+
+static int vaapi_encode_av1_set_tile(AVCodecContext *avctx)
+{
+    VAAPIEncodeAV1Context *priv = avctx->priv_data;
+    int mi_cols, mi_rows, sb_shift, sb_size;
+    int max_tile_width_sb, max_tile_area_sb;
+    int min_log2_tile_cols, max_log2_tile_cols, max_log2_tile_rows;
+    int min_log2_tiles, min_log2_tile_rows;
+
+    /** TODO: consider to add an option of using 128x128 block. */
+    priv->enable_128x128_superblock = 0;
+
+    mi_cols = 2 * ((avctx->width + 7) >> 3);
+    mi_rows = 2 * ((avctx->height + 7) >> 3);
+    priv->sb_cols = priv->enable_128x128_superblock ?
+                    ((mi_cols + 31) >> 5) : ((mi_cols + 15) >> 4);
+    priv->sb_rows = priv->enable_128x128_superblock ?
+                    ((mi_rows + 31) >> 5) : ((mi_rows + 15) >> 4);
+    sb_shift = priv->enable_128x128_superblock ? 5 : 4;
+    sb_size  = sb_shift + 2;
+    max_tile_width_sb = AV1_MAX_TILE_WIDTH >> sb_size;
+    max_tile_area_sb  = AV1_MAX_TILE_AREA  >> (2 * sb_size);
+
+    min_log2_tile_cols = tile_log2(max_tile_width_sb, priv->sb_cols);
+    max_log2_tile_cols = tile_log2(1, FFMIN(priv->sb_cols, AV1_MAX_TILE_COLS));
+    max_log2_tile_rows = tile_log2(1, FFMIN(priv->sb_rows, AV1_MAX_TILE_ROWS));
+    min_log2_tiles     = FFMAX(min_log2_tile_cols,
+                               tile_log2(max_tile_area_sb, priv->sb_rows * priv->sb_cols));
+    min_log2_tile_rows = FFMAX(min_log2_tiles - priv->tile_cols_log2, 0);
+
+    if (priv->tile_cols_log2 != av_clip(priv->tile_cols_log2, min_log2_tile_cols, max_log2_tile_cols) ||
+        priv->tile_rows_log2 != av_clip(priv->tile_rows_log2, min_log2_tile_rows, max_log2_tile_rows)) {
+        priv->tile_cols_log2 = av_clip(priv->tile_cols_log2, min_log2_tile_cols, max_log2_tile_cols);
+        priv->tile_rows_log2 = av_clip(priv->tile_rows_log2, min_log2_tile_rows, max_log2_tile_rows);
+        av_log(avctx, AV_LOG_WARNING, "Correct tile cols/rows log2 to %d/%d.\n",
+               priv->tile_cols_log2,
+               priv->tile_rows_log2);
+    }
+
+    /** only support uniformed tile mode. */
+    priv->tile_width_sb  = (priv->sb_cols + (1 << priv->tile_cols_log2) - 1) >>
+                            priv->tile_cols_log2;
+    priv->tile_height_sb = (priv->sb_rows + (1 << priv->tile_rows_log2) - 1) >>
+                            priv->tile_rows_log2;
+    priv->tile_cols = (priv->sb_cols + priv->tile_width_sb - 1) / priv->tile_width_sb;
+    priv->tile_rows = (priv->sb_rows + priv->tile_height_sb - 1) / priv->tile_height_sb;
+
+    /** check if tile cols/rows is supported by driver. */
+    if ((priv->tile_cols - 1) > priv->attr_ext2.bits.max_tile_cols_minus1 ||
+        (priv->tile_rows - 1) > priv->attr_ext2.bits.max_tile_rows_minus1) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupported tile cols/rows %d/%d, "
+               "should be less than %d/%d.\n", priv->tile_cols, priv->tile_rows,
+               priv->attr_ext2.bits.max_tile_cols_minus1 + 1,
+               priv->attr_ext2.bits.max_tile_rows_minus1 + 1);
+        return AVERROR(EINVAL);
+    }
+    av_log(avctx, AV_LOG_DEBUG, "Setting tile cols/rows to %d/%d.\n",
+           priv->tile_cols, priv->tile_rows);
+
+    /** check if tile group numbers is valid. */
+    if (priv->tile_groups > priv->tile_cols * priv->tile_rows) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid tile groups %d, "
+        "should be less than %d.\n", priv->tile_groups, priv->tile_cols * priv->tile_rows);
+        return AVERROR(EINVAL);
+    }
+
+    return 0;
+}
+
+static int vaapi_encode_av1_write_sequence_header(AVCodecContext *avctx,
+                                                  char *data, size_t *data_len)
+{
+    VAAPIEncodeAV1Context *priv = avctx->priv_data;
+
+    memcpy(data, &priv->sh_data, MAX_PARAM_BUFFER_SIZE * sizeof(char));
+    *data_len = priv->sh_data_len;
+
+    return 0;
+}
+
+static int vaapi_encode_av1_init_sequence_params(AVCodecContext *avctx)
+{
+    VAAPIEncodeContext               *ctx = avctx->priv_data;
+    VAAPIEncodeAV1Context           *priv = avctx->priv_data;
+    AV1RawOBU                     *sh_obu = &priv->sh;
+    AV1RawSequenceHeader              *sh = &sh_obu->obu.sequence_header;
+    VAEncSequenceParameterBufferAV1 *vseq = ctx->codec_sequence_params;
+    CodedBitstreamFragment           *obu = &priv->current_obu;
+    const AVPixFmtDescriptor *desc;
+    int ret;
+
+    memset(sh_obu, 0, sizeof(*sh_obu));
+    sh_obu->header.obu_type = AV1_OBU_SEQUENCE_HEADER;
+
+    desc = av_pix_fmt_desc_get(priv->common.input_frames->sw_format);
+    av_assert0(desc);
+
+    sh->seq_profile  = avctx->profile;
+    if (!sh->seq_force_screen_content_tools)
+        sh->seq_force_integer_mv = AV1_SELECT_INTEGER_MV;
+    sh->frame_width_bits_minus_1  = av_log2(avctx->width);
+    sh->frame_height_bits_minus_1 = av_log2(avctx->height);
+    sh->max_frame_width_minus_1   = avctx->width - 1;
+    sh->max_frame_height_minus_1  = avctx->height - 1;
+    sh->enable_order_hint         = 1;
+    sh->order_hint_bits_minus_1   = av_log2(avctx->gop_size);
+    sh->seq_tier[0]               = priv->tier;
+    sh->use_128x128_superblock    = priv->enable_128x128_superblock;
+
+    sh->color_config = (AV1RawColorConfig) {
+        .high_bitdepth                  = desc->comp[0].depth == 8 ? 0 : 1,
+        .color_primaries                = avctx->color_primaries,
+        .transfer_characteristics       = avctx->color_trc,
+        .matrix_coefficients            = avctx->colorspace,
+        .color_description_present_flag = (avctx->color_primaries != AVCOL_PRI_UNSPECIFIED ||
+                                           avctx->color_trc       != AVCOL_TRC_UNSPECIFIED ||
+                                           avctx->colorspace      != AVCOL_SPC_UNSPECIFIED),
+        .subsampling_x                  = desc->log2_chroma_w,
+        .subsampling_y                  = desc->log2_chroma_h,
+    };
+
+    if (avctx->level != FF_LEVEL_UNKNOWN) {
+        sh->seq_level_idx[0] = avctx->level;
+    } else {
+        const AV1LevelDescriptor *level;
+        float framerate;
+
+        if (avctx->framerate.num > 0 && avctx->framerate.den > 0)
+            framerate = avctx->framerate.num / avctx->framerate.den;
+        else
+            framerate = 0;
+
+        level = ff_av1_guess_level(avctx->bit_rate, priv->tier,
+                                   ctx->surface_width, ctx->surface_height,
+                                   priv->tile_rows * priv->tile_cols,
+                                   priv->tile_cols, framerate);
+        if (level) {
+            av_log(avctx, AV_LOG_VERBOSE, "Using level %s.\n", level->name);
+            sh->seq_level_idx[0] = level->level_idx;
+        } else {
+            av_log(avctx, AV_LOG_VERBOSE, "Stream will not conform to "
+                   "any normal level, using level 6.3 by default.\n");
+            sh->seq_level_idx[0] = 19;
+            sh->seq_tier[0] = 1;
+        }
+    }
+    vseq->seq_profile             = sh->seq_profile;
+    vseq->seq_level_idx           = sh->seq_level_idx[0];
+    vseq->seq_tier                = sh->seq_tier[0];
+    vseq->order_hint_bits_minus_1 = sh->order_hint_bits_minus_1;
+    vseq->intra_period            = ctx->gop_size;
+    vseq->ip_period               = ctx->b_per_p + 1;
+    vseq->order_hint_bits_minus_1 = sh->order_hint_bits_minus_1;
+
+    vseq->seq_fields.bits.enable_order_hint = sh->enable_order_hint;
+
+    if (!(ctx->va_rc_mode & VA_RC_CQP)) {
+        vseq->bits_per_second = ctx->va_bit_rate;
+        vseq->seq_fields.bits.enable_cdef = sh->enable_cdef = 1;
+    }
+
+    ret = vaapi_encode_av1_add_obu(avctx, obu, AV1_OBU_SEQUENCE_HEADER, &priv->sh);
+    if (ret < 0)
+        goto end;
+
+    ret = vaapi_encode_av1_write_obu(avctx, priv->sh_data, &priv->sh_data_len, obu);
+    if (ret < 0)
+        goto end;
+
+end:
+    ff_cbs_fragment_reset(obu);
+    return ret;
+}
+
+static int vaapi_encode_av1_init_picture_params(AVCodecContext *avctx,
+                                                VAAPIEncodePicture *pic)
+{
+    VAAPIEncodeContext              *ctx = avctx->priv_data;
+    VAAPIEncodePicture             *prev = pic->prev;
+    VAAPIEncodeAV1Picture         *hprev = prev ? prev->priv_data : NULL;
+    VAAPIEncodeAV1Context          *priv = avctx->priv_data;
+    VAAPIEncodeAV1Picture          *hpic = pic->priv_data;
+    AV1RawOBU                    *fh_obu = &priv->fh;
+    AV1RawFrameHeader                *fh = &fh_obu->obu.frame.header;
+    VAEncPictureParameterBufferAV1 *vpic = pic->codec_picture_params;
+    CodedBitstreamAV1Context      *cbctx = priv->cbc->priv_data;
+    CodedBitstreamFragment          *obu = &priv->current_obu;
+    VAAPIEncodeAV1Picture *href0, *href1;
+    int offset, slot, i;
+    int ret;
+    static const int8_t default_loop_filter_ref_deltas[AV1_TOTAL_REFS_PER_FRAME] =
+        { 1, 0, 0, 0, -1, 0, -1, -1 };
+
+    memset(fh_obu, 0, sizeof(*fh_obu));
+    pic->nb_slices = priv->tile_groups;
+    fh_obu->header.obu_type = AV1_OBU_FRAME_HEADER;
+
+    switch (pic->type) {
+    case PICTURE_TYPE_IDR:
+        av_assert0(pic->nb_refs == 0);
+        fh->frame_type = AV1_FRAME_KEY;
+        fh->refresh_frame_flags = 0xff;
+        fh->base_q_idx = priv->q_idx_idr;
+        hpic->slot = 0;
+        hpic->last_idr_frame = pic->display_order;
+        break;
+    case PICTURE_TYPE_P:
+        av_assert0(pic->nb_refs == 1);
+        fh->frame_type = AV1_FRAME_INTER;
+        fh->base_q_idx = priv->q_idx_p;
+        hpic->last_idr_frame = hprev->last_idr_frame;
+        href0 = pic->refs[0]->priv_data;
+        vpic->ref_frame_ctrl_l0.fields.search_idx0 = 1;
+
+        av_assert0(href0->slot == 0 || href0->slot == 1);
+
+        if (ctx->max_b_depth > 0) {
+            hpic->slot = !href0->slot;
+            fh->refresh_frame_flags = 1 << hpic->slot | 0xfc;
+            for (i=0; i < AV1_NUM_REF_FRAMES; i++) {
+                fh->ref_order_hint[i] = pic->refs[0]->display_order - hpic->last_idr_frame;
+            }
+
+            if (hpic->slot) {
+                for (i=0; i <= AV1_REFS_PER_FRAME; i++)
+                    fh->ref_frame_idx[i] = 0;
+                if (pic->refs[0]->refs[0])
+                    fh->ref_order_hint[1] = pic->refs[0]->refs[0]->display_order - hpic->last_idr_frame;
+            } else {
+                for (i=0; i <= AV1_REFS_PER_FRAME; i++)
+                    fh->ref_frame_idx[i] = 1;
+                fh->primary_ref_frame = 1;
+                if (pic->refs[0]->refs[0])
+                    fh->ref_order_hint[0] = pic->refs[0]->refs[0]->display_order - hpic->last_idr_frame;
+            }
+        } else {
+            hpic->slot = 0;
+            fh->refresh_frame_flags = 0xff;
+            for (i=0; i < AV1_NUM_REF_FRAMES; i++)
+                fh->ref_order_hint[i] = pic->refs[0]->display_order - hpic->last_idr_frame;
+        }
+        break;
+    case PICTURE_TYPE_B:
+        av_assert0(pic->nb_refs == 2);
+        href0 = pic->refs[0]->priv_data;
+        href1 = pic->refs[1]->priv_data;
+        av_assert0(href0->slot < pic->b_depth + 1 &&
+                   href1->slot < pic->b_depth + 1);
+        fh->frame_type = AV1_FRAME_INTER;
+        fh->base_q_idx = priv->q_idx_b;
+        fh->refresh_frame_flags = 0x0;
+        fh->reference_select = 1;
+        hpic->last_idr_frame = hprev->last_idr_frame;
+        vpic->ref_frame_ctrl_l0.fields.search_idx0 = 1;
+        vpic->ref_frame_ctrl_l1.fields.search_idx0 = 5;
+
+        if (href0->slot) {
+            for (i=0; i < 4; i++) {
+                fh->ref_frame_idx[i] = 1;
+            }
+            for (i=4; i < 7; i++) {
+                fh->ref_frame_idx[i] = 0;
+            }
+            for (i=0; i < AV1_NUM_REF_FRAMES; i++)
+                fh->ref_order_hint[i] = pic->refs[1]->display_order - hpic->last_idr_frame;
+            fh->ref_order_hint[1] = pic->refs[0]->display_order - hpic->last_idr_frame;
+            fh->primary_ref_frame = 1;
+        } else {
+            for (i=0; i < 4; i++) {
+                fh->ref_frame_idx[i] = 0;
+            }
+            for (i=4; i < 7; i++) {
+                fh->ref_frame_idx[i] = 1;
+            }
+
+            for (i=0; i < AV1_NUM_REF_FRAMES; i++) {
+                fh->ref_order_hint[i] = pic->refs[1]->display_order - hpic->last_idr_frame;
+            }
+            fh->ref_order_hint[0] = pic->refs[0]->display_order - hpic->last_idr_frame;
+        }
+        break;
+    default:
+        av_assert0(0 && "invalid picture type");
+    }
+
+    fh->show_frame                = pic->display_order <= pic->encode_order;
+    fh->showable_frame            = fh->frame_type != AV1_FRAME_KEY;
+    fh->frame_width_minus_1       = avctx->width - 1;
+    fh->frame_height_minus_1      = avctx->height - 1;
+    fh->render_width_minus_1      = fh->frame_width_minus_1;
+    fh->render_height_minus_1     = fh->frame_height_minus_1;
+    fh->order_hint                = pic->display_order - hpic->last_idr_frame;
+    fh->tile_cols                 = priv->tile_cols;
+    fh->tile_rows                 = priv->tile_rows;
+    fh->tile_cols_log2            = priv->tile_cols_log2;
+    fh->tile_rows_log2            = priv->tile_rows_log2;
+    fh->uniform_tile_spacing_flag = 1;
+    fh->tile_size_bytes_minus1    = priv->attr_ext2.bits.tile_size_bytes_minus1;
+    pic->cache_coded_frame        = !fh->show_frame;
+
+    if (priv->attr_ext2.bits.tx_mode_support)
+        fh->tx_mode = priv->attr_ext2.bits.tx_mode_support;
+
+    for (i=0; i < fh->tile_cols - 1; i++)
+        fh->width_in_sbs_minus_1[i] = priv->tile_width_sb - 1;
+    fh->width_in_sbs_minus_1[i] = priv->sb_cols - (fh->tile_cols - 1) * priv->tile_width_sb - 1;
+
+    for (i=0; i < fh->tile_rows - 1; i++)
+        fh->height_in_sbs_minus_1[i] = priv->tile_height_sb - 1;
+    fh->height_in_sbs_minus_1[i] = priv->sb_rows - (fh->tile_rows - 1) * priv->tile_height_sb - 1;
+
+    for (i=0; i < fh->tile_cols; i++)
+        vpic->width_in_sbs_minus_1[i] = fh->width_in_sbs_minus_1[i];
+    for (i=0; i < fh->tile_rows; i++)
+        vpic->height_in_sbs_minus_1[i] = fh->height_in_sbs_minus_1[i];
+
+    memcpy(fh->loop_filter_ref_deltas, default_loop_filter_ref_deltas,
+           AV1_TOTAL_REFS_PER_FRAME * sizeof(int8_t));
+
+    if (fh->frame_type == AV1_FRAME_KEY) {
+        fh->error_resilient_mode = 1;
+        fh->refresh_frame_flags = (1 << AV1_NUM_REF_FRAMES) - 1;
+    }
+
+    if (fh->frame_type == AV1_FRAME_KEY || fh->error_resilient_mode)
+        fh->primary_ref_frame = AV1_PRIMARY_REF_NONE;
+
+    vpic->base_qindex          = fh->base_q_idx;
+    vpic->frame_width_minus_1  = fh->frame_width_minus_1;
+    vpic->frame_height_minus_1 = fh->frame_height_minus_1;
+    vpic->primary_ref_frame    = fh->primary_ref_frame;
+    vpic->reconstructed_frame  = pic->recon_surface;
+    vpic->coded_buf            = pic->output_buffer;
+    vpic->tile_cols            = fh->tile_cols;
+    vpic->tile_rows            = fh->tile_rows;
+    vpic->order_hint           = fh->order_hint;
+
+    vpic->picture_flags.bits.enable_frame_obu     = 0;
+    vpic->picture_flags.bits.frame_type           = fh->frame_type;
+    vpic->picture_flags.bits.reduced_tx_set       = fh->reduced_tx_set;
+    vpic->picture_flags.bits.error_resilient_mode = fh->error_resilient_mode;
+
+    vpic->mode_control_flags.bits.reference_mode = fh->reference_select;
+    vpic->mode_control_flags.bits.tx_mode = fh->tx_mode;
+
+    vpic->tile_group_obu_hdr_info.bits.obu_has_size_field = 1;
+
+    /** set reference. */
+    for (i = 0; i < AV1_REFS_PER_FRAME; i++)
+        vpic->ref_frame_idx[i] = fh->ref_frame_idx[i];
+
+    for (i = 0; i < FF_ARRAY_ELEMS(vpic->reference_frames); i++)
+        vpic->reference_frames[i] = VA_INVALID_SURFACE;
+    for (i = 0; i < pic->nb_refs; i++) {
+        VAAPIEncodePicture *ref_pic = pic->refs[i];
+
+        slot = ((VAAPIEncodeAV1Picture*)ref_pic->priv_data)->slot;
+        av_assert0(vpic->reference_frames[slot] == VA_INVALID_SURFACE);
+
+        vpic->reference_frames[slot] = ref_pic->recon_surface;
+    }
+
+    /** set default values in BRC mode, it will be overwritten by low level driver */
+    if (!(ctx->va_rc_mode & VA_RC_CQP)) {
+        fh->loop_filter_level[0] = 1;
+        fh->loop_filter_level[1] = 1;
+        fh->loop_filter_level[2] = 1;
+        fh->loop_filter_level[3] = 1;
+    }
+
+    /** pack frame header, then set va params offset like bit_offset_qindex etc. */
+    ret = vaapi_encode_av1_add_obu(avctx, obu, AV1_OBU_FRAME_HEADER , &priv->fh);
+    if (ret < 0)
+        goto end;
+
+    ret = vaapi_encode_av1_write_obu(avctx, priv->fh_data, &priv->fh_data_len, obu);
+    if (ret < 0)
+        goto end;
+
+    if (!(ctx->va_rc_mode & VA_RC_CQP)) {
+        vpic->min_base_qindex = av_clip(avctx->qmin, 1, AV1_MAX_QUANT);
+        vpic->max_base_qindex = av_clip(avctx->qmax, 1, AV1_MAX_QUANT);
+
+        offset = cbctx->frame_header_data_offset - cbctx->frame_header_start_position;
+        vpic->bit_offset_qindex            = offset + cbctx->qindex_offset;
+        vpic->bit_offset_loopfilter_params = offset + cbctx->loopfilter_offset;
+        vpic->bit_offset_cdef_params       = offset + cbctx->cdef_start_offset;
+        vpic->size_in_bits_cdef_params     = cbctx->cdef_end_offset - cbctx->cdef_start_offset;
+        vpic->size_in_bits_frame_hdr_obu   = priv->fh_data_len;
+    }
+
+    vpic->byte_offset_frame_hdr_obu_size = (((pic->type == PICTURE_TYPE_IDR) ?
+                                            priv->sh_data_len/8 : 0) +
+                                            (fh_obu->header.obu_extension_flag ?
+                                            2 : 1));
+
+
+end:
+    ff_cbs_fragment_reset(obu);
+    return ret;
+}
+
+static int vaapi_encode_av1_init_slice_params(AVCodecContext *avctx,
+                                               VAAPIEncodePicture *pic,
+                                               VAAPIEncodeSlice *slice)
+{
+    VAAPIEncodeAV1Context      *priv = avctx->priv_data;
+    VAEncTileGroupBufferAV1  *vslice = slice->codec_slice_params;
+    CodedBitstreamAV1Context  *cbctx = priv->cbc->priv_data;
+    int div;
+
+    /** Set tile group info. */
+    div = priv->tile_cols * priv->tile_rows / priv->tile_groups;
+    vslice->tg_start = slice->index * div;
+    if (slice->index == (priv->tile_groups - 1)) {
+        vslice->tg_end = priv->tile_cols * priv->tile_rows - 1;
+        cbctx->seen_frame_header = 0;
+    } else {
+        vslice->tg_end = (slice->index + 1) * div - 1;
+    }
+
+    return 0;
+}
+
+static int vaapi_encode_av1_write_picture_header(AVCodecContext *avctx,
+                                                 VAAPIEncodePicture *pic,
+                                                 char *data, size_t *data_len)
+{
+    AV1RawOBU fh_obu;
+    VAAPIEncodeAV1Context *priv = avctx->priv_data;
+    CodedBitstreamFragment *obu = &priv->current_obu;
+    AV1RawFrameHeader   *rep_fh = &fh_obu.obu.frame_header;
+    VAAPIEncodeAV1Picture *href0;
+    int ret;
+
+    pic->tail_size = 0;
+    /** Pack repeat frame header. */
+    if ((pic->type == PICTURE_TYPE_B) && (pic->next->type == PICTURE_TYPE_P)) {
+        memset(&fh_obu, 0, sizeof(fh_obu));
+        href0 = pic->refs[0]->priv_data;
+        pic->tail_size = MAX_PARAM_BUFFER_SIZE;
+        fh_obu.header.obu_type = AV1_OBU_FRAME_HEADER;
+        rep_fh->show_existing_frame   = 1;
+        rep_fh->frame_to_show_map_idx = href0->slot == 0;
+        rep_fh->frame_type            = AV1_FRAME_INTER;
+        rep_fh->frame_width_minus_1   = avctx->width - 1;
+        rep_fh->frame_height_minus_1  = avctx->height - 1;
+        rep_fh->render_width_minus_1  = rep_fh->frame_width_minus_1;
+        rep_fh->render_height_minus_1 = rep_fh->frame_height_minus_1;
+
+        ret = vaapi_encode_av1_add_obu(avctx, obu, AV1_OBU_FRAME_HEADER, &fh_obu);
+        if (ret < 0)
+            goto end;
+
+        ret = vaapi_encode_av1_write_obu(avctx, pic->tail_data, &pic->tail_size, obu);
+        if (ret < 0)
+            goto end;
+
+        pic->tail_size /= 8;
+
+        ff_cbs_fragment_reset(obu);
+    }
+
+    memcpy(data, &priv->fh_data, MAX_PARAM_BUFFER_SIZE * sizeof(char));
+    *data_len = priv->fh_data_len;
+
+end:
+    ff_cbs_fragment_reset(obu);
+    return ret;
+}
+
+static const VAAPIEncodeProfile vaapi_encode_av1_profiles[] = {
+    { FF_PROFILE_AV1_MAIN,  8, 3, 1, 1, VAProfileAV1Profile0 },
+    { FF_PROFILE_AV1_MAIN, 10, 3, 1, 1, VAProfileAV1Profile0 },
+    { FF_PROFILE_UNKNOWN }
+};
+
+static const VAAPIEncodeType vaapi_encode_type_av1 = {
+    .profiles        = vaapi_encode_av1_profiles,
+    .flags           = FLAG_CONSTANT_QUALITY_ONLY |
+                       FLAG_B_PICTURES |
+                       FLAG_B_PICTURE_REFERENCES,
+    .default_quality = 25,
+    .configure       = &vaapi_encode_av1_configure,
+
+    .sequence_header_type  = VAEncPackedHeaderSequence,
+    .sequence_params_size  = sizeof(VAEncSequenceParameterBufferAV1),
+    .init_sequence_params  = &vaapi_encode_av1_init_sequence_params,
+    .write_sequence_header = &vaapi_encode_av1_write_sequence_header,
+
+    .picture_priv_data_size = sizeof(VAAPIEncodeAV1Picture),
+    .picture_header_type    = VAEncPackedHeaderPicture,
+    .picture_params_size    = sizeof(VAEncPictureParameterBufferAV1),
+    .init_picture_params    = &vaapi_encode_av1_init_picture_params,
+    .write_picture_header   = &vaapi_encode_av1_write_picture_header,
+
+    .slice_params_size = sizeof(VAEncTileGroupBufferAV1),
+    .init_slice_params = &vaapi_encode_av1_init_slice_params,
+};
+
+static av_cold int vaapi_encode_av1_init(AVCodecContext *avctx)
+{
+    VAAPIEncodeContext      *ctx = avctx->priv_data;
+    VAAPIEncodeAV1Context  *priv = avctx->priv_data;
+    VAConfigAttrib attr;
+    int ret;
+
+    ctx->codec = &vaapi_encode_type_av1;
+
+    ctx->surface_width  = FFALIGN(avctx->width,  16);
+    ctx->surface_height = FFALIGN(avctx->height, 16);
+
+    ctx->desired_packed_headers =
+        VA_ENC_PACKED_HEADER_SEQUENCE |
+        VA_ENC_PACKED_HEADER_PICTURE;
+        //VA_ENC_PACKED_HEADER_SLICE;
+
+    if (avctx->level == FF_LEVEL_UNKNOWN)
+        avctx->level = priv->level;
+
+    if (avctx->level != FF_LEVEL_UNKNOWN && avctx->level & ~0x1f) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid level %d\n", avctx->level);
+        return AVERROR(EINVAL);
+    }
+
+    ret = ff_vaapi_encode_init(avctx);
+    if (ret < 0)
+        return ret;
+
+    attr.type = VAConfigAttribEncAV1;
+    ret = ff_vaapi_encode_get_attributs(avctx, &attr);
+    if (ret < 0)
+        return ret;
+    if (attr.value == VA_ATTRIB_NOT_SUPPORTED)
+        priv->attr.value = 0;
+    else
+        priv->attr.value = attr.value;
+
+    attr.type = VAConfigAttribEncAV1Ext1;
+    ret = ff_vaapi_encode_get_attributs(avctx, &attr);
+    if (ret < 0)
+        return ret;
+    if (attr.value == VA_ATTRIB_NOT_SUPPORTED)
+        priv->attr_ext1.value = 0;
+    else
+        priv->attr_ext1.value = attr.value;
+
+    attr.type = VAConfigAttribEncAV1Ext2;
+    ret = ff_vaapi_encode_get_attributs(avctx, &attr);
+    if (ret < 0)
+        return ret;
+    if (attr.value == VA_ATTRIB_NOT_SUPPORTED)
+        priv->attr_ext2.value = 0;
+    else
+        priv->attr_ext2.value = attr.value;
+
+    ret = vaapi_encode_av1_set_tile(avctx);
+    if (ret < 0)
+        return ret;
+
+    return 0;
+}
+
+static av_cold int vaapi_encode_av1_close(AVCodecContext *avctx)
+{
+    VAAPIEncodeAV1Context *priv = avctx->priv_data;
+
+    ff_cbs_fragment_free(&priv->current_obu);
+    ff_cbs_close(&priv->cbc);
+
+    return ff_vaapi_encode_close(avctx);
+}
+
+#define OFFSET(x) offsetof(VAAPIEncodeAV1Context, x)
+#define FLAGS (AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM)
+
+static const AVOption vaapi_encode_av1_options[] = {
+    VAAPI_ENCODE_COMMON_OPTIONS,
+    VAAPI_ENCODE_RC_OPTIONS,
+    { "tier", "Set tier (seq_tier)",
+      OFFSET(tier), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, FLAGS, "tier" },
+    { "main", NULL, 0, AV_OPT_TYPE_CONST,
+      { .i64 = 0 }, 0, 0, FLAGS, "tier" },
+    { "high", NULL, 0, AV_OPT_TYPE_CONST,
+      { .i64 = 1 }, 0, 0, FLAGS, "tier" },
+    { "level", "Set level (seq_level_idx)",
+      OFFSET(level), AV_OPT_TYPE_INT,
+      { .i64 = FF_LEVEL_UNKNOWN }, FF_LEVEL_UNKNOWN, 0x1f, FLAGS, "level" },
+
+#define LEVEL(name, value) name, NULL, 0, AV_OPT_TYPE_CONST, \
+      { .i64 = value }, 0, 0, FLAGS, "level"
+    { LEVEL("2.0",  0) },
+    { LEVEL("2.1",  1) },
+    { LEVEL("3.0",  4) },
+    { LEVEL("3.1",  5) },
+    { LEVEL("4.0",  8) },
+    { LEVEL("4.1",  9) },
+    { LEVEL("5.0", 12) },
+    { LEVEL("5.1", 13) },
+    { LEVEL("5.2", 14) },
+    { LEVEL("5.3", 15) },
+    { LEVEL("6.0", 16) },
+    { LEVEL("6.1", 17) },
+    { LEVEL("6.2", 18) },
+    { LEVEL("6.3", 19) },
+#undef LEVEL
+
+    { "tile_cols_log2", "Log2 of columns number for tiled encoding",
+      OFFSET(tile_cols_log2), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, av_log2(AV1_MAX_TILE_COLS), FLAGS },
+    { "tile_rows_log2", "Log2 of rows number for tiled encoding",
+      OFFSET(tile_rows_log2), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, av_log2(AV1_MAX_TILE_ROWS), FLAGS },
+    { "tile_groups", "Number of tile groups for encoding",
+      OFFSET(tile_groups), AV_OPT_TYPE_INT, { .i64 = 1 }, 1, AV1_MAX_TILE_ROWS * AV1_MAX_TILE_COLS, FLAGS },
+
+    { NULL },
+};
+
+static const AVCodecDefault vaapi_encode_av1_defaults[] = {
+    { "b",              "0"   },
+    { "bf",             "0"   },
+    { "g",              "120" },
+    { "i_qfactor",      "1"   },
+    { "i_qoffset",      "0"   },
+    { "b_qfactor",      "6/5" },
+    { "b_qoffset",      "0"   },
+    { "qmin",           "1"   },
+    { "qmax",           "255" },
+    { NULL },
+};
+
+static const AVClass vaapi_encode_av1_class = {
+    .class_name = "av1_vaapi",
+    .item_name  = av_default_item_name,
+    .option     = vaapi_encode_av1_options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+AVCodec ff_av1_vaapi_encoder = {
+    .name           = "av1_vaapi",
+    .long_name      = NULL_IF_CONFIG_SMALL("AV1 (VAAPI)"),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_AV1,
+    .priv_data_size = sizeof(VAAPIEncodeAV1Context),
+    .init           = &vaapi_encode_av1_init,
+    .receive_packet = &ff_vaapi_encode_receive_packet,
+    .close          = &vaapi_encode_av1_close,
+    .priv_class     = &vaapi_encode_av1_class,
+    .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .defaults       = vaapi_encode_av1_defaults,
+    .pix_fmts = (const enum AVPixelFormat[]) {
+        AV_PIX_FMT_VAAPI,
+        AV_PIX_FMT_NONE,
+    },
+    .hw_configs     = ff_vaapi_encode_hw_configs,
+    .wrapper_name   = "vaapi",
+};
diff --git a/tests/fate/libavcodec.mak b/tests/fate/libavcodec.mak
index aa199e0..0d1fc96 100644
--- a/tests/fate/libavcodec.mak
+++ b/tests/fate/libavcodec.mak
@@ -56,6 +56,11 @@ fate-h265-levels: libavcodec/tests/h265_levels$(EXESUF)
 fate-h265-levels: CMD = run libavcodec/tests/h265_levels$(EXESUF)
 fate-h265-levels: REF = /dev/null
 
+FATE_LIBAVCODEC-$(CONFIG_AV1_VAAPI_ENCODER) += fate-av1-levels
+fate-av1-levels: libavcodec/tests/av1_levels$(EXESUF)
+fate-av1-levels: CMD = run libavcodec/tests/av1_levels$(EXESUF)
+fate-av1-levels: REF = /dev/null
+
 FATE_LIBAVCODEC-$(CONFIG_IIRFILTER) += fate-iirfilter
 fate-iirfilter: libavcodec/tests/iirfilter$(EXESUF)
 fate-iirfilter: CMD = run libavcodec/tests/iirfilter$(EXESUF)
-- 
1.8.3.1

