From 1b9e1a25646ed9f8616aa24691d9eef8fa3cd7ad Mon Sep 17 00:00:00 2001
From: Wenbin Chen <wenbin.chen@intel.com>
Date: Tue, 19 Oct 2021 06:42:00 +0000
Subject: [PATCH 18/18] qsvenc_av1: Add split and merge bsf to qsv_av1 encoder

The coded bitsteam got from VPL does not obey the TU rules. It does not
contain exactly one show frame in one packet. av1_frame_split and
av1_frame_merge filter are added to qsv_av1 encoder to reorder the
packet.

Signed-off-by: Wenbin Chen <wenbin.chen@intel.com>
---
 libavcodec/qsvenc.c     |  40 -------------
 libavcodec/qsvenc.h     |   2 -
 libavcodec/qsvenc_av1.c | 128 +++++++++++++++++++++++++++++++++++++++-
 3 files changed, 126 insertions(+), 44 deletions(-)

diff --git a/libavcodec/qsvenc.c b/libavcodec/qsvenc.c
index e93695ba3a..f4c17ba439 100644
--- a/libavcodec/qsvenc.c
+++ b/libavcodec/qsvenc.c
@@ -1281,29 +1281,6 @@ static int qsv_retrieve_enc_av1_params(AVCodecContext *avctx, QSVEncContext *q)
                                   "Error calling GetVideoParam");
 
     q->packet_size = q->param.mfx.BufferSizeInKB * q->param.mfx.BRCParamMultiplier * 1000;
-
-    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
-        const AVBitStreamFilter *filter = av_bsf_get_by_name("extract_extradata");
-        int ret;
-
-        if (!filter) {
-            av_log(avctx, AV_LOG_ERROR, "extract_extradata bitstream filter "
-                   "not found. This is a bug, please report it.\n");
-            return AVERROR_BUG;
-        }
-        ret = av_bsf_alloc(filter, &q->bsf);
-        if (ret < 0)
-            return ret;
-
-        ret = avcodec_parameters_from_context(q->bsf->par_in, avctx);
-        if (ret < 0)
-           return ret;
-
-        ret = av_bsf_init(q->bsf);
-        if (ret < 0)
-           return ret;
-    }
-
     dump_video_av1_param(avctx, q, ext_buffers);
 
     return 0;
@@ -2029,22 +2006,6 @@ int ff_qsv_encode(AVCodecContext *avctx, QSVEncContext *q,
 
         av_packet_move_ref(pkt, &new_pkt);
 
-        if (avctx->codec_id == AV_CODEC_ID_AV1 && avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
-            ret = av_bsf_send_packet(q->bsf, pkt);
-            if (ret < 0) {
-                av_log(avctx, AV_LOG_ERROR, "extract_extradata filter "
-                    "failed to send input packet\n");
-                return ret;
-            }
-
-            ret = av_bsf_receive_packet(q->bsf, pkt);
-            if (ret < 0) {
-                av_log(avctx, AV_LOG_ERROR, "extract_extradata filter "
-                    "failed to receive output packet\n");
-                return ret;
-            }
-        }
-
         *got_packet = 1;
     }
 
@@ -2103,7 +2064,6 @@ int ff_qsv_enc_close(AVCodecContext *avctx, QSVEncContext *q)
 #endif
 
     av_freep(&q->extparam);
-    av_bsf_free(&q->bsf);
 
     return 0;
 }
diff --git a/libavcodec/qsvenc.h b/libavcodec/qsvenc.h
index 6e885e7bfe..36b95ea2f1 100644
--- a/libavcodec/qsvenc.h
+++ b/libavcodec/qsvenc.h
@@ -220,8 +220,6 @@ typedef struct QSVEncContext {
     int forced_idr;
 
     int main10sp;
-
-    AVBSFContext *bsf;
 } QSVEncContext;
 
 int ff_qsv_enc_init(AVCodecContext *avctx, QSVEncContext *q);
diff --git a/libavcodec/qsvenc_av1.c b/libavcodec/qsvenc_av1.c
index 17528beafe..1a09bb6a71 100644
--- a/libavcodec/qsvenc_av1.c
+++ b/libavcodec/qsvenc_av1.c
@@ -34,28 +34,152 @@
 
 typedef struct QSVAV1EncContext {
     AVClass *class;
+    AVBSFContext *extra_data_bsf;
+    AVBSFContext *reorder_bsf;
     QSVEncContext qsv;
+    AVFifoBuffer *packet_fifo;
     int load_plugin;
 } QSVAV1EncContext;
 
 static av_cold int qsv_enc_init(AVCodecContext *avctx)
 {
     QSVAV1EncContext *q = avctx->priv_data;
+    int ret;
+
+    ret = av_bsf_list_parse_str("av1_frame_split,av1_frame_merge", &q->reorder_bsf);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Error creating bitstream filters "
+                "av1_frame_split,av1_frame_merge \n");
+        return ret;
+    }
+    ret = avcodec_parameters_from_context(q->reorder_bsf->par_in, avctx);
+    if (ret < 0)
+        return ret;
+    ret = av_bsf_init(q->reorder_bsf);
+    if (ret < 0)
+        return ret;
+
+    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
+        const AVBitStreamFilter *filter = av_bsf_get_by_name("extract_extradata");
+        if (!filter) {
+            av_log(avctx, AV_LOG_ERROR, "Cannot get extract_extradata bitstream filter\n");
+            return AVERROR_BUG;
+        }
+        ret = av_bsf_alloc(filter, &q->extra_data_bsf);
+        if (ret < 0)
+            return ret;
+        ret = avcodec_parameters_from_context(q->extra_data_bsf->par_in, avctx);
+        if (ret < 0)
+           return ret;
+        ret = av_bsf_init(q->extra_data_bsf);
+        if (ret < 0)
+           return ret;
+    }
+
+    q->packet_fifo = av_fifo_alloc(sizeof(AVPacket));
 
     return ff_qsv_enc_init(avctx, &q->qsv);
 }
 
+static int qsv_reorder_bitstream(QSVAV1EncContext *q, AVPacket *pkt, int *got_packet)
+{
+    int ret = 0, flush = 0;
+
+    if (!*got_packet)
+        flush = 1;
+
+    if (av_fifo_space(q->packet_fifo) < sizeof(*pkt)) {
+        ret = av_fifo_realloc2(q->packet_fifo,
+                        av_fifo_size(q->packet_fifo) + sizeof(*pkt));
+        if (ret < 0)
+            return ret;
+    }
+    if (*got_packet)
+        av_fifo_generic_write(q->packet_fifo, pkt, sizeof(*pkt), NULL);
+    *got_packet = 0;
+
+    while (1) {
+        ret = av_bsf_receive_packet(q->reorder_bsf, pkt);
+        if (ret == AVERROR(EAGAIN)) { //need more input
+            if (av_fifo_size(q->packet_fifo))
+                av_fifo_generic_read(q->packet_fifo, pkt, sizeof(*pkt), NULL);
+            else if (!flush)
+                return ret;
+
+            ret = av_bsf_send_packet(q->reorder_bsf, pkt);
+            if (ret < 0) {
+                av_log(q, AV_LOG_ERROR, "reorder_bsr "
+                    "failed to send packet\n");
+                return ret;
+            }
+            continue;
+        } else if (ret < 0 && ret != AVERROR_EOF) {
+            av_log(q, AV_LOG_ERROR, "reorder_bsr "
+                "failed to receive packet\n");
+            return ret;
+        }
+        break;
+    }
+    if (pkt && pkt->data)
+        *got_packet = 1;
+    return 0;
+}
+
 static int qsv_enc_frame(AVCodecContext *avctx, AVPacket *pkt,
                          const AVFrame *frame, int *got_packet)
 {
     QSVAV1EncContext *q = avctx->priv_data;
-
-    return ff_qsv_encode(avctx, &q->qsv, pkt, frame, got_packet);
+    int ret;
+
+    while (1) {
+        ret = ff_qsv_encode(avctx, &q->qsv, pkt, frame, got_packet);
+        if (ret < 0)
+            return ret;
+
+        //skip beginning phase when there are no output.
+        if (!(frame && !*got_packet)) {
+            ret = qsv_reorder_bitstream(q, pkt, got_packet);
+            if (ret == AVERROR(EAGAIN) && !frame)
+            //If start to flush, we should not return EAGAIN
+                continue;
+            else if (ret < 0)
+                return ret;
+        }
+        break;
+    }
+
+    if (*got_packet && avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
+        ret = av_bsf_send_packet(q->extra_data_bsf, pkt);
+        if (ret < 0) {
+            av_log(avctx, AV_LOG_ERROR, "extract_extradata filter "
+                "failed to send input packet\n");
+            return ret;
+        }
+
+        ret = av_bsf_receive_packet(q->extra_data_bsf, pkt);
+        if (ret < 0) {
+            av_log(avctx, AV_LOG_ERROR, "extract_extradata filter "
+                "failed to receive output packet\n");
+            return ret;
+        }
+    }
+
+    return ret;
 }
 
 static av_cold int qsv_enc_close(AVCodecContext *avctx)
 {
     QSVAV1EncContext *q = avctx->priv_data;
+    AVPacket pkt;
+
+    av_bsf_free(&q->extra_data_bsf);
+    av_bsf_free(&q->reorder_bsf);
+
+    while(av_fifo_size(q->packet_fifo)) {
+        av_fifo_generic_read(q->packet_fifo, &pkt, sizeof(pkt), NULL);
+        av_packet_unref(&pkt);
+    }
+    av_fifo_freep(&q->packet_fifo);
 
     return ff_qsv_enc_close(avctx, &q->qsv);
 }
-- 
2.25.1

