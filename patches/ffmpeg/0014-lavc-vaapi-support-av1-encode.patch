From 4954cfb28d380913b38a6c7e1c62b9481a8cb574 Mon Sep 17 00:00:00 2001
From: Fei Wang <fei.w.wang@intel.com>
Date: Tue, 26 Jan 2021 15:57:33 +0800
Subject: [PATCH 14/15] lavc/vaapi: support av1 encode.

ffmpeg -hwaccel vaapi -vaapi_device /dev/dri/renderD128 -v verbose \
-f rawvideo -pix_fmt yuv420p -s:v 704x576 -i input.yuv             \
-vf 'format=nv12,hwupload' -c:v av1_vaapi -rc_mode CQP -g 30       \
-qp 10 -low_power 1 -vframes 150 -y out.ivf

Signed-off-by: Fei Wang <fei.w.wang@intel.com>
---
 libavcodec/Makefile             |   1 +
 libavcodec/allcodecs.c          |   1 +
 libavcodec/av1.h                |   7 +
 libavcodec/cbs_av1.c            |   2 +-
 libavcodec/va_private_enc_av1.h | 936 ++++++++++++++++++++++++++++++++++++++++
 libavcodec/vaapi_encode.c       |  37 +-
 libavcodec/vaapi_encode.h       |   4 +
 libavcodec/vaapi_encode_av1.c   | 579 +++++++++++++++++++++++++
 8 files changed, 1565 insertions(+), 2 deletions(-)
 create mode 100644 libavcodec/va_private_enc_av1.h
 create mode 100644 libavcodec/vaapi_encode_av1.c

diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index d187614..df486bb 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -232,6 +232,7 @@ OBJS-$(CONFIG_AV1_CUVID_DECODER)       += cuviddec.o
 OBJS-$(CONFIG_AV1_QSV_DECODER)         += qsvdec.o
 OBJS-$(CONFIG_AV1_QSV_ENCODER)         += qsvenc_av1.o
 OBJS-$(CONFIG_AVRN_DECODER)            += avrndec.o
+OBJS-$(CONFIG_AV1_VAAPI_ENCODER)       += vaapi_encode_av1.o
 OBJS-$(CONFIG_AVRP_DECODER)            += r210dec.o
 OBJS-$(CONFIG_AVRP_ENCODER)            += r210enc.o
 OBJS-$(CONFIG_AVS_DECODER)             += avs.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 35bc771..1d39925 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -795,6 +795,7 @@ extern const AVCodec ff_av1_decoder;
 extern const AVCodec ff_av1_cuvid_decoder;
 extern const AVCodec ff_av1_qsv_decoder;
 extern const AVCodec ff_av1_qsv_encoder;
+extern const AVCodec ff_av1_vaapi_encoder;
 extern const AVCodec ff_libopenh264_encoder;
 extern const AVCodec ff_libopenh264_decoder;
 extern const AVCodec ff_h264_amf_encoder;
diff --git a/libavcodec/av1.h b/libavcodec/av1.h
index 0f99ae4..61b93d3 100644
--- a/libavcodec/av1.h
+++ b/libavcodec/av1.h
@@ -168,4 +168,11 @@ enum {
     AV1_RESTORE_SWITCHABLE = 3,
 };
 
+// TX mode (section 6.8.21)
+enum {
+    AV1_ONLY_4X4       = 0,
+    AV1_TX_MODE_LARGEST     = 1,
+    AV1_TX_MODE_SELECT    = 2,
+};
+
 #endif /* AVCODEC_AV1_H */
diff --git a/libavcodec/cbs_av1.c b/libavcodec/cbs_av1.c
index 302e1f3..4a285ee 100644
--- a/libavcodec/cbs_av1.c
+++ b/libavcodec/cbs_av1.c
@@ -1204,7 +1204,7 @@ static int cbs_av1_write_obu(CodedBitstreamContext *ctx,
                 pbc->buf + start_pos, header_size);
         skip_put_bytes(pbc, header_size);
 
-        if (td) {
+        if (td && td->data) {
             memcpy(pbc->buf + data_pos + header_size,
                    td->data, td->data_size);
             skip_put_bytes(pbc, td->data_size);
diff --git a/libavcodec/va_private_enc_av1.h b/libavcodec/va_private_enc_av1.h
new file mode 100644
index 0000000..f62158d
--- /dev/null
+++ b/libavcodec/va_private_enc_av1.h
@@ -0,0 +1,936 @@
+/*
+ * Copyright (c) 2007-2021 Intel Corporation. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file va_private_enc_av1.h
+ * \brief AV1 encoding API
+ *
+ * This file contains the \ref api_enc_av1 "AV1 encoding API".
+ *
+ */
+
+#ifndef VA_ENC_AV1_H
+#define VA_ENC_AV1_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \defgroup api_enc_AV1 AV1 encoding API
+ *
+ * @{
+ */
+#define VAConfigAttribEncAV1      50
+#define VAConfigAttribEncAV1Ext1  51
+#define VAConfigAttribEncAV1Ext2  52
+
+/** \brief Attribute value for VAConfigAttribEncAV1. */
+typedef union _VAConfigAttribValEncAV1 {
+    struct {
+        /**
+         * \brief A flag indicates whether 128x128 supper block supported,
+         * 0 if 128x128 supper block  not supported, 1 if supported.
+         * 2 if device does not support not enabling this feature.
+         */
+        uint32_t use_128x128_superblock        : 2;
+        /**
+         * \brief  A flag indicates whether filter intra is supported.
+         * 0 if intra filter not supported, 1 if supported.
+         * 2 if device does not support not enabling this feature.
+         */
+        uint32_t enable_filter_intra           : 2;
+        /**
+         * \brief  A flag indicates whether intra edge filter is supported.
+         * 0 if intra edge filter not supported, 1 if supported.
+         * 2 if device does not support not enabling this feature.
+         */
+        uint32_t enable_intra_edge_filter      : 2;
+        /**
+         * \brief  A flag indicates whether interintra compound is supported.
+         * 0 if interintra compound not supported, 1 if supported.
+         * 2 if device does not support not enabling this feature.
+         */
+        uint32_t enable_interintra_compound    : 2;
+        /**
+         * \brief  A flag indicates whether masked compound is supported.
+         * 0 if masked compound not supported, 1 if supported.
+         * 2 if device does not support not enabling this feature.
+         */
+        uint32_t enable_masked_compound        : 2;
+        /**
+         * \brief  A flag indicates whether warped motion is supported.
+         * 0 if warped motion not supported, 1 if supported.
+         * 2 if device does not support not enabling this feature.
+         */
+        uint32_t enable_warped_motion          : 2;
+        /**
+         * \brief  A flag indicates whether screen content tools are supported.
+         * 0 if screen content tools not supported, 1 if supported.
+         * 2 if device does not support not enabling this feature.
+         */
+        uint32_t enable_screen_content_tools   : 2;
+        /**
+         * \brief  A flag indicates whether dual filter is supporedt.
+         * 0 if dual filter not supported, 1 if supported.
+         * 2 if device does not support not enabling this feature.
+         */
+        uint32_t enable_dual_filter            : 2;
+        /**
+         * \brief  A flag indicates whether jnt comp is supported.
+         * 0 if jnt comp not supported, 1 if supported.
+         * 2 if device does not support not enabling this feature.
+         */
+        uint32_t enable_jnt_comp               : 2;
+        /**
+         * \brief  A flag indicates whether ref frame mvs is supported.
+         * 0 if ref frames mvs not supported, 1 if supported.
+         * 2 if device does not support not enabling this feature.
+         */
+        uint32_t enable_ref_frame_mvs          : 2;
+        /**
+         * \brief  A flag indicates whether super resolution is supported.
+         * 0 if superres not supported, 1 if supported.
+         * 2 if device does not support not enabling this feature.
+         */
+        uint32_t enable_superres               : 2;
+        /**
+         * \brief  A flag indicates whether restoration is supported.
+         * 0 if restorationnot supported, 1 if supported.
+         * 2 if device does not support not enabling this feature.
+         */
+        uint32_t enable_restoration            : 2;
+        /**
+         * \brief  A flag indicates whether intrac is supported.
+         * 0 if intrac not supported, 1 if supported.
+         * 2 if device does not support not enabling this feature.
+         */
+        uint32_t allow_intrabc                 : 2;
+        /**
+         * \brief  A flag indicates whether cdef channel strength is supported.
+         * 0 if cdef not supported, 1 if supported.
+         * 2 if device does not support not enabling this feature.
+         */
+        uint32_t cdef_channel_strength_support : 2;
+        /** \brief Reserved bits for future, must be zero. */
+        uint32_t reserved                      : 4;
+    } bits;
+    uint32_t value;
+} VAConfigAttribValEncAV1;
+
+/** \brief Attribute value for VAConfigAttribEncAV1Ext1. */
+typedef union _VAConfigAttribValEncAV1Ext1 {
+    struct {
+        /**
+         * \brief Fields indicate which types of interpolation filter are supported.
+         * (interp_filter_type & 0x01) == 1: eight_tap filter is supported, 0: not.
+         * (interp_filter_type & 0x02) == 1: eight_tap_smooth filter is supported, 0: not.
+         * (interp_filter_type & 0x04) == 1: eight_sharp filter is supported, 0: not.
+         * (interp_filter_type & 0x08) == 1: bilinear filter is supported, 0: not.
+         * (interp_filter_type & 0x10) == 1: switchable filter is supported, 0: not.
+         */
+        uint32_t interp_filter_type            : 5;
+        /**
+         * \brief Min segmentId block size accepted.
+         */
+        uint32_t min_segid_block_size_accepted : 8;
+        /**
+         * \brief Type of segment feature support.
+         * (segment_feature_support & 0x01) == 1: SEG_LVL_ALT_Q is supported, 0: not.
+         * (segment_feature_support & 0x02) == 1: SEG_LVL_ALT_LF_Y_V is supported, 0: not.
+         * (segment_feature_support & 0x04) == 1: SEG_LVL_ALT_LF_Y_H is supported, 0: not.
+         * (segment_feature_support & 0x08) == 1: SEG_LVL_ALT_LF_U is supported, 0: not.
+         * (segment_feature_support & 0x10) == 1: SEG_LVL_ALT_LF_V is supported, 0: not.
+         * (segment_feature_support & 0x20) == 1: SEG_LVL_REF_FRAME is supported, 0: not.
+         * (segment_feature_support & 0x40) == 1: SEG_LVL_SKIP is supported, 0: not.
+         * (segment_feature_support & 0x80) == 1: SEG_LVL_GLOBALMV is supported, 0: not.
+         */
+        uint32_t segment_feature_support       : 8;
+        /** \brief Reserved bits for future, must be zero. */
+        uint32_t reserved                      : 11;
+    } bits;
+    uint32_t value;
+} VAConfigAttribValEncAV1Ext1;
+
+/** \brief Attribute value for VAConfigAttribEncAV1Ext2. */
+typedef union _VAConfigAttribValEncAV1Ext2 {
+    struct {
+        /**
+        * \brief Tile size bytes minus1.
+        * Specify the number of bytes needed to code tile size.
+        * This value will be set in frame header obu.
+        */
+        uint32_t tile_size_bytes_minus1        : 2;
+        /**
+         * \brief tx_mode supported.
+         */
+        uint32_t tx_mode_support               : 2;
+        /**
+         * \brief Max tile rows minus1.
+         * Specify the max number of tile in row supported by driver.
+         */
+        uint32_t max_tile_rows_minus1          : 6;
+        /**
+         * \brief Max tile cols minus1.
+         * Specify the max number of tile in col supported by driver.
+         */
+        uint32_t max_tile_cols_minus1          : 6;
+        /**
+         * \brief Max tile num minus1.
+         * Specify the max number of tile supported bt driver.
+         */
+        uint32_t max_tile_num_minus1           : 12;
+        /** \brief Reserved bits for future, must be zero. */
+        uint32_t reserved                      : 4;
+    } bits;
+    uint32_t value;
+} VAConfigAttribValEncAV1Ext2;
+
+/**
+ * \brief Packed header types specific to AV1 encoding.
+ *
+ * Types of packed headers generally used for AV1 encoding.
+ *
+ */
+typedef enum {
+    /**
+     * \brief Packed Sequence Parameter Set (SPS).
+     *
+     * The corresponding packed header data buffer shall contain the
+     * complete sequence_header_obu() syntax element.
+     *
+     */
+    VAEncPackedHeaderAV1_SPS = VAEncPackedHeaderSequence,
+    /**
+     * \brief Packed Picture Parameter Set (PPS).
+     *
+     * The corresponding packed header data buffer shall contain the
+     * complete frame_header_obu() syntax element.
+     *
+     */
+    VAEncPackedHeaderAV1_PPS = VAEncPackedHeaderPicture,
+} VAEncPackedHeaderTypeAV1;
+
+/**
+ * \brief AV1 Encoding Sequence Parameter Buffer Structure
+ *
+ * This structure conveys sequence level parameters.
+ *
+ */
+typedef struct  _VAEncSequenceParameterBufferAV1 {
+    /** \brief AV1 profile setting.
+     *  value range [0..2].
+     */
+    uint8_t     seq_profile;
+
+    /** \brief Level Setting of current operation point.
+     *  value range [0..23].
+     */
+    uint8_t     seq_level_idx;
+
+    /** \brief Tier Setting of current operation point.
+     *  value range [0..1].
+     */
+    uint8_t     seq_tier;
+
+    uint8_t     reserved8b;
+
+    /** \brief Period between intro_only frames. */
+    uint32_t    intra_period;
+
+    /** \brief Period between I/P frames.
+     *  For hierarchical structure, this is the anchor frame distance. */
+    uint32_t    ip_period;
+
+    /* \brief RC related fields. RC modes are set with VAConfigAttribRateControl. */
+    /* For AV1, CBR implies HRD conformance and VBR implies no HRD conformance. */
+
+    /**
+     * \brief Initial bitrate set for this sequence in CBR or VBR modes.
+     *
+     * This field represents the initial bitrate value for this
+     * sequence if CBR or VBR mode is used, i.e. if the encoder
+     * pipeline was created with a #VAConfigAttribRateControl
+     * attribute set to either \ref VA_RC_CBR or \ref VA_RC_VBR.
+     *
+     * The bitrate can be modified later on through
+     * #VAEncMiscParameterRateControl buffers.
+     */
+    uint32_t    bits_per_second;
+
+    union {
+        struct {
+            /** \brief Still picture encoding, no inter frame referencing. */
+            uint32_t    still_picture                               : 1;
+            /** \brief Force using 128x128 or 64x64 Supper block */
+            uint32_t    use_128x128_superblock                      : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    enable_filter_intra                         : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    enable_intra_edge_filter                    : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    enable_interintra_compound                  : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    enable_masked_compound                      : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    enable_warped_motion                        : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    enable_dual_filter                          : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    enable_order_hint                           : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    enable_jnt_comp                             : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    enable_ref_frame_mvs                        : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    enable_superres                             : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    enable_cdef                                 : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    enable_restoration                          : 1;
+            /** \brief Reserved bytes for future use, must be zero. */
+            uint32_t    reserved_bits                               : 18;
+        } bits;
+        uint32_t value;
+    } seq_fields;
+
+    /** \brief Corresponds to AV1 syntax element of the same name.
+     *  value range [0..7].
+     */
+    uint8_t     order_hint_bits_minus_1;
+
+    /** \brief Reserved bytes for future use, must be zero */
+    uint32_t                va_reserved[VA_PADDING_HIGH];
+} VAEncSequenceParameterBufferAV1;
+
+#define VA_AV1_MAXNUM_SEGMENTS                  8
+#define VA_AV1_MAXNUM_SEGFEATURES               8
+
+/**
+ * \brief Segment parameters
+ */
+typedef struct _VAEncSegParamAV1 {
+    union {
+        struct {
+            /** \brief Indicates if segmentation is enabled in the current frame.
+             *  If disabled, all the below parameters in the structure should
+             *  be set to 0, and ignored by driver.
+             */
+            uint8_t     segmentation_enabled            : 1;
+
+            /** \brief when segmentation_enabled equals 1 and segment_number > 0,
+             *  this parameter equals 1 indicates the segmentation map may
+             *  come from DDI, and that the Segmentation Map Data Buffer
+             *  should be provided with populated segment_id. If equals 0,
+             *  segmentation map should be inherited from a reference frame
+             *  (specified by primary_ref_frame). When segmentation_enabled or
+             *  SegmentNumber equals 0, this parameter should be set to 0
+             *  and ignored by driver.
+             */
+            uint8_t     segmentation_update_map         : 1;
+            uint8_t     segmentation_temporal_update    : 1;
+            /** \brief Reserved bytes for future use, must be zero. */
+            uint8_t     reserved                        : 5;
+
+        } bits;
+        uint8_t value;
+    } seg_flags;
+
+    /** \brief If segmentation_enabled equals 1, this parameter indicates
+     *  the number of segments conveyed through VAAPI. In this case,
+     *  if segment_number equals 0, it forces the underline encoder
+     *  to determine how many segments would be created as well as
+     *  the segmentation map to be generated. Also the underline
+     *  encoder shall write the segmentation_params() syntax in the
+     *  uncompressed header at segmentation_bitoffset (back-annotation).
+     *  In VAAPI, the rest parameters in this structure should be all
+     *  set to 0 and ignored by driver. And app should NOT send the
+     *  "Segment map data buffer". In packed uncompressed header
+     *  bitstream, app should write syntax element segmentation_enabled
+     *  as 0 and segmentation_params() should be only 1-bit-long.
+     *  If segment_number > 0, and segmentation_update_map = 1, app should provide
+     *  the "Segment map data buffer" and populate the rest of the
+     *  current data structure. And that underline encoder would honor
+     *  the segmentation parameters feature_data[0..segment_number-1][]
+     *  and feature_mask[0..segment_number-1], etc.
+     *  Value range [0..8].
+     */
+    uint8_t      segment_number;
+
+    /** \brief segment parameters.
+     *  feature_data[][] is equivalent to variable FeatureData[][] in spec,
+     *  which is after clip3() operation.
+     *  Clip3(x, y, z) = (z<x)? x : ((z > y)? y : z);
+     *  The limit is defined in Segmentation_Feature_Max[ SEG_LVL_MAX ] = {
+     *  255, MAX_LOOP_FILTER, MAX_LOOP_FILTER, MAX_LOOP_FILTER,
+     *  MAX_LOOP_FILTER, 7, 0, 0 }
+     */
+    int16_t     feature_data[VA_AV1_MAXNUM_SEGMENTS][VA_AV1_MAXNUM_SEGFEATURES];
+
+    /** \brief Bit field to indicate each feature is enabled or not per
+     *  segment_id. Each bit is the feature_id.
+     */
+    uint8_t     feature_mask[VA_AV1_MAXNUM_SEGMENTS];
+
+    /** \brief Reserved bytes for future use, must be zero. */
+    uint32_t                va_reserved[VA_PADDING_LOW];
+} VAEncSegParamAV1;
+
+/**
+ * \brief Segment map data buffer
+ * This buffer is optional depending on the value of av1_segments.segmentation_enabled.
+ * If av1_segments.segmentation_enabled in the picture parameters equals 1,
+ * and RateControlMethod is not CQP and this surface is not provided by App,
+ * the encoder will determine the per block segmentation map. In this case,
+ * App should not provide the segmentation parameter data structure
+ * in frame header as well. If av1_segments.segmentation_enabled equals 1
+ * and the segmentation map buffer is provided, app should embed the
+ * segmentation info in frame header, populate the VAEncSegParamAV1 structure with
+ * #VAEncMacroblockMapBufferType and the driver as well as the underline encoder
+ * should honor what is given by the app.
+ */
+typedef struct _VAEncSegMapBufferAV1 {
+    /** \brief Segment map data size */
+    uint32_t    segmentMapDataSize;
+
+    /**
+     * \brief Segment map
+     * Size of this map is indicated by \ref segmentMapDataSize and each element
+	 * in this map contains the segment id of a particular block.
+     * The element is indexed by raster scan order.
+     * The value of each entry should be in the range [0..7], inclusive.
+     */
+    uint8_t    *pSegmentMap;
+} VAEncSegMapBufferAV1;
+
+typedef enum {
+    /** \brief Identity transformation, 0-parameter */
+    VAAV1EncTransformationIdentity           = 0,
+    /** \brief Translational motion, 2-parameter */
+    VAAV1EncTransformationTranslation        = 1,
+    /** \brief Simplified affine with rotation + zoom only, 4-parameter */
+    VAAV1EncTransformationRotzoom            = 2,
+    /** \brief Affine, 6-parameter */
+    VAAV1EncTransformationAffine             = 3,
+    /** \brief Transformation count */
+    VAAV1EncTransformationCount
+} VAEncTransformationTypeAV1;
+
+typedef struct _VAEncWarpedMotionParamsAV1{
+
+    /** \brief Specify the type of warped motion */
+    VAEncTransformationTypeAV1  wmtype;
+
+    /** \brief Specify warp motion parameters
+     *  wm.wmmat[] corresponds to gm_params[][] in spec.
+     *  Details in AV1 spec section 5.9.24 or refer to libaom code
+     *  https://aomedia.googlesource.com/aom/+/refs/heads/master/av1/decoder/decodeframe.c
+     */
+    int32_t                 wmmat[8];
+
+    /** \brief Valid or invalid on affine set */
+    uint8_t  invalid;
+
+    /** \brief Reserved bytes for future use, must be zero. */
+    uint32_t                va_reserved[VA_PADDING_LOW];
+
+} VAEncWarpedMotionParamsAV1;
+
+/**
+ * \brief Reference frame control
+ * Suggest which frames to be used as reference.
+ * search_idx#: index into ref_frame_idx[] to indicate that frame will be included
+ * in the reference list if value in range [1..7]. Invalid when value is 0.
+ * The order of the search_idx# indicates the preferred search order.
+ */
+typedef union {
+	struct
+	{
+        /**
+         * \brief Specifies preferred search order of reference frame
+         * which comes from indexing ref_frame_idx[] by 0.
+         */
+        uint32_t search_idx0 : 3;
+        /**
+         * \brief Specifies preferred search order of reference frame
+         * which comes from indexing ref_frame_idx[] by 1.
+         */
+        uint32_t search_idx1 : 3;
+        /**
+         * \brief Specifies preferred search order of reference frame
+         * which comes from indexing ref_frame_idx[] by 2.
+         */
+        uint32_t search_idx2 : 3;
+        /**
+         * \brief Specifies preferred search order of reference frame
+         * which comes from indexing ref_frame_idx[] by 3.
+         */
+        uint32_t search_idx3 : 3;
+        /**
+         * \brief Specifies preferred search order of reference frame
+         * which comes from indexing ref_frame_idx[] by 4.
+         */
+        uint32_t search_idx4 : 3;
+        /**
+         * \brief Specifies preferred search order of reference frame
+         * which comes from indexing ref_frame_idx[] by 5.
+         */
+        uint32_t search_idx5 : 3;
+        /**
+         * \brief Specifies preferred search order of reference frame
+         * which comes from indexing ref_frame_idx[] by 6.
+         */
+        uint32_t search_idx6 : 3;
+
+        /** \brief Reserved bytes for future use, must be zero. */
+        uint32_t Reserved    : 11;
+	} fields;
+	uint32_t value;
+} VARefFrameCtrlAV1;
+
+/**
+ * \brief AV1 Encoding Picture Parameter Buffer Structure
+ *
+ * This structure conveys picture level parameters.
+ *
+ */
+typedef struct  _VAEncPictureParameterBufferAV1
+{
+    /** \brief AV1 encoder may support SupRes and dynamic scaling function.
+     *  For SupRes, underline encoder is responsible to do downscaling.
+     *  For dynamic scaling, app should provide the scaled raw source.
+     */
+    /** \brief Raw source frame width in pixels */
+    uint16_t    frame_width_minus_1;
+    /** \brief Raw source frame height in pixels */
+    uint16_t    frame_height_minus_1;
+
+    /** \brief Surface to store reconstructed frame, not used for enc only case */
+    VASurfaceID reconstructed_frame;
+
+    /** \brief Buffer to store coded data */
+    VABufferID  coded_buf;
+
+    /** \brief Reference frame buffers
+     *  Each entry of the array specifies the surface index of the picture
+     *  that is referred by current picture or will be referred by any future
+     *  picture. The valid entries take value from 0 to 127, inclusive.
+     *  Non-valid entries, those do not point to pictures which are referred
+     *  by current picture or future pictures, should take value 0xFF.
+     *  Other values are not allowed.
+     *
+     *  Application should update this array based on the refreshing
+     *  information expected.
+     */
+    VASurfaceID reference_frames[8];
+
+    /** \brief Reference index list
+     *  Contains a list of indices into refernce_frames[].
+     *  Indice with refernce frames range: [LAST_FRAME - LAST_FRAME,
+     *  LAST2_FRAME - LAST_FRAME, ..., ALTREF2_FRAME - LAST_FRAME].
+     *  #define LAST_FRAME 1
+     *  #define LAST2_FRAME 2
+     *  #define LAST3_FRAME 3
+     *  #define GOLDEN_FRAME 4
+     *  #define BWDREF_FRAME 5
+     *  #define ALTREF_FRAME 6
+     *  #define ALTREF2_FRAME 7
+     *  value range [0..7].
+     */
+    uint8_t     ref_frame_idx[7];
+
+    uint8_t     reserved8bits0;
+
+    /** \brief primary reference frame
+     *  Index into reference_frames[]
+     *  segment id map, context table, etc. come from the reference
+     *  frame pointed by this index.
+     *  value range [0..7].
+     */
+    uint8_t     primary_ref_frame;
+
+    /** \brief Corresponds to AV1 syntax element of the same name. */
+    uint8_t     order_hint;
+
+    /** \brief Suggest which frames to be used as reference
+     *  see struct #VARefFrameCtrl for details.
+     */
+    VARefFrameCtrlAV1     ref_frame_ctrl_l0;
+    VARefFrameCtrlAV1     ref_frame_ctrl_l1;
+
+    union {
+        struct {
+            /** \brief frame type
+             *  0:  key_frame
+             *  1:  inter_frame
+             *  2:  intra_only frame
+             *  3:  switch_frame (app needs to set error_resilient_mode=1,
+             *      refresh_frame_flags, etc approperately.)
+             */
+            uint32_t    frame_type                      : 2;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    error_resilient_mode            : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    disable_cdf_update              : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    use_superres                    : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    allow_high_precision_mv         : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    use_ref_frame_mvs               : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    disable_frame_end_update_cdf    : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    reduced_tx_set                  : 1;
+
+            /** \brief For single tile group, app may choose to use one frame obu
+             *  to replace one frame header obu + one tile group obu.
+             *  Invalid if num_tile_groups_minus1 > 0.
+             */
+            uint32_t    enable_frame_obu                : 1;
+
+            /** \brief Indicate the current frame will be used as a long term reference. */
+            uint32_t    long_term_reference             : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint32_t    allow_intrabc                   : 1;
+            /** \brief Reserved bytes for future use, must be zero. */
+            uint32_t    reserved                        : 20;
+        } bits;
+        uint32_t value;
+    } picture_flags;
+
+    /** \brief Block size for each Segment ID in Segment Map.
+     *  0: 16x16 block size, default value;
+     *  1: 32x32 block size;
+     *  2: 64x64 block size;
+     *  3: 8x8 block size.
+     */
+    uint8_t     seg_id_block_size;
+
+    /** \brief Number of tile groups minus 1.
+     *  value range [0..255].
+     */
+    uint8_t     num_tile_groups_minus1;
+
+    /** \brief Temporal id of the frame.*/
+    uint8_t     temporal_id;
+
+    /** \brief Deblock filter parameters.
+     *  value range [0..63].
+     */
+    uint8_t     filter_level[2];
+    uint8_t     filter_level_u;
+    uint8_t     filter_level_v;
+
+    union {
+        struct {
+            /* \brief Sharpness level for deblock filter.
+             * value range [0..7].
+             */
+            uint8_t     sharpness_level                 : 3;
+            uint8_t     mode_ref_delta_enabled          : 1;
+            uint8_t     mode_ref_delta_update           : 1;
+            /** \brief Reserved bytes for future use, must be zero. */
+            uint8_t     reserved                        : 3;
+        } bits;
+        uint8_t    value;
+    } loop_filter_flags;
+
+    /** \brief Super resolution scale denominator.
+     *  value range [9..16].
+     */
+    uint8_t     superres_scale_denominator;
+    /** \brief Corresponds to AV1 syntax element of the same name. */
+    uint8_t     interpolation_filter;
+
+    /** \brief Loop filter ref deltas.
+     *  value range [-63..63].
+     */
+    int8_t      ref_deltas[8];
+
+    /** \brief Loop filter mode deltas.
+     *  value range [-63..63].
+     */
+    int8_t      mode_deltas[2];
+
+    /** \brief Quantization params*/
+    uint8_t     base_qindex;
+    int8_t      y_dc_delta_q;
+    int8_t      u_dc_delta_q;
+    int8_t      u_ac_delta_q;
+    int8_t      v_dc_delta_q;
+    int8_t      v_ac_delta_q;
+
+    /** \brief Min value for base q index for BRC.
+     *  value range [1..255].
+     */
+    uint8_t     min_base_qindex;
+
+    /** \brief Max value for base q index for BRC.
+     *  value range [1..255].
+     */
+    uint8_t     max_base_qindex;
+
+    /** \brief Quantization matrix. */
+    union {
+        struct {
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint16_t    using_qmatrix                   : 1;
+            /* \brief Following parameters only valid when using_qmatrix == 1. */
+            uint16_t    qm_y                            : 4;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint16_t    qm_u                            : 4;
+            /** \brief Corresponds to AV1 syntax element of the same name. */
+            uint16_t    qm_v                            : 4;
+            /** \brief Reserved bytes for future use, must be zero. */
+            uint16_t    reserved                        : 3;
+        } bits;
+        uint16_t    value;
+    } qmatrix_flags;
+
+    uint16_t reserved16bits0;
+
+    union {
+        struct {
+            /** \brief Specify whether quantizer index delta values are present.
+             *  value range [0..1]*/
+            uint32_t    delta_q_present                 : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name.
+             *  value range [0..3]*/
+            uint32_t    delta_q_res                     : 2;
+
+            /** \brief Specify whether loop filter delta values are present.
+             *  value range [0..1]*/
+            uint32_t    delta_lf_present                : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name.
+             *  value range [0..3]*/
+            uint32_t    delta_lf_res                    : 2;
+            /** \brief Corresponds to AV1 syntax element of the same name.
+             *  value range [0..1]*/
+            uint32_t    delta_lf_multi                  : 1;
+
+            /** \brief Corresponds to AV1 syntax element of the same name.
+             *  0: ONLY_4X4;
+             *  1: TX_MODE_LARGEST;
+             *  2: TX_MODE_SELECT;
+             *  3: Invalid.
+             */
+            uint32_t    tx_mode                         : 2;
+
+            /** \brief Indicates whether to use single or compound reference prediction.
+             *  0: SINGLE_REFERENCE;
+             *  1: COMPOUND_REFERENCE;
+             *  2: REFERENCE_MODE_SELECT;
+             *  3: REFERENCE_MODES.
+             */
+            uint32_t    reference_mode                  : 2;
+            /** \brief Corresponds to AV1 syntax element of the same name.
+             *  value range [0..1].
+             */
+            uint32_t    reduced_tx_set                  : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name.
+             *  value range [0..1].
+             */
+            uint32_t    skip_mode_present               : 1;
+            /** \brief Reserved bytes for future use, must be zero. */
+            uint32_t    reserved                        : 19;
+        } bits;
+        uint32_t    value;
+    } mode_control_flags;
+
+    /** \brief Segmentation parameters */
+    VAEncSegParamAV1    segments;
+
+    /** \brief Number of tile columns. */
+    uint8_t     tile_cols;
+    /** \brief Number of tile rows. */
+    uint8_t     tile_rows;
+
+    /** \brief The last tile column or row size needs to be derived. */
+    uint16_t    width_in_sbs_minus_1[63];
+    uint16_t    height_in_sbs_minus_1[63];
+
+    /** \brief specify which tile to use for the CDF update.
+     *  value range [0..127]*/
+    uint16_t     context_update_tile_id;
+
+    /** \brief Corresponds to AV1 syntax element of the same name.
+     *  value range [0..3].
+     */
+    uint8_t     cdef_damping_minus_3;
+    /** \brief Corresponds to AV1 syntax element of the same name.
+     *  value range [0..3].
+     */
+    uint8_t     cdef_bits;
+    /** \brief CDEF Y strengths.
+     *  value range [0..63]*/
+    uint8_t     cdef_y_strengths[8];
+    /** \brief CDEF UV strengths.
+     *  value range [0..63]*/
+    uint8_t     cdef_uv_strengths[8];
+
+    union {
+        struct {
+            /** \brief Restoration type for Y frame.
+             *  value range [0..3].
+             */
+            uint16_t    yframe_restoration_type         : 2;
+            /** \brief Restoration type for Cb frame.
+             *  value range [0..3].
+             */
+            uint16_t    cbframe_restoration_type        : 2;
+            /** \brief Restoration type for Cr frame.
+             *  value range [0..3].
+             */
+            uint16_t    crframe_restoration_type        : 2;
+            /** \brief Corresponds to AV1 syntax element of the same name.
+             *  value range [0..2].
+             */
+            uint16_t    lr_unit_shift                   : 2;
+            /** \brief Corresponds to AV1 syntax element of the same name.
+             *  value range [0..1].
+             */
+            uint16_t    lr_uv_shift                     : 1;
+            /** \brief Reserved bytes for future use, must be zero. */
+            uint16_t    reserved                        : 7;
+        } bits;
+        uint16_t    value;
+    } loop_restoration_flags;
+
+    /** \brief Global motion. */
+    VAEncWarpedMotionParamsAV1    wm[7];
+
+    /**
+     *  \brief Offset from starting position of output bitstream in bits where
+     *  Base Qindex should be inserted.
+     */
+    uint32_t    bit_offset_qindex;
+    /**
+     *  \brief Offset from starting position in bits where segmentation_enabled
+     *  is located in bitstream. When segmentation is generated by
+     *  encoder, GPU uses this offset to locate and update the
+     *  segmentation related information.
+     */
+    uint32_t    bit_offset_segmentation;
+    /**
+     *  \brief Offset in bits for syntax loop_filter_params( ) in packed frame
+     *  header bit stream from the start of the packed header data.
+     *  Valid only in BRC mode. In CQP mode, this parameter should
+     *  be set to 0 and ignored by driver.
+     */
+    uint32_t    bit_offset_loopfilter_params;
+    /**
+     *  \brief In BRC mode, underline encoder should generate the approperiate
+     *  CDEF values and write back into uncompressed header. And app
+     *  should provide default CDEF values in packed header. This parameter
+     *  should point to the starting bit of cdef_params() syntax structure
+     *  in packed header.
+     *  In CQP mode, this parameter should be set to 0 and ignored by driver.
+     */
+    uint32_t    bit_offset_cdef_params;
+    /**
+     *  \brief In BRC mode, this parameter indicates the actual bit usage of
+     *  cdef_params() syntax structure in packed uncompressed header.
+     *  In CQP mode, this parameter should be set to 0 and ignored by driver.
+     */
+    uint32_t    size_in_bits_cdef_params;
+
+    /**
+     *  \brief Offset in bytes for syntax obu_size of frame header OBU in packed
+     *  frame header bit stream. The frame header OBU size depends on the
+     *  encoded tile sizes. It applies to both Frame Header OBU and Frame
+     *  OBU if obu_size needs to be updated by underline encoder.
+     *  Otherwise, app can set it to 0 and ignored by driver.
+     */
+    uint32_t    byte_offset_frame_hdr_obu_size;
+
+    /**
+	 * \brief Frame header OBU bit stream size in bits. The frame header obu packed bit
+	 * stream contains an obu header, a 4-byte long obu_size field, frame_header_obu()
+	 * syntax chain, and a trailing bit if not inside a frame obu. If EnableFrameOBU == 1,
+	 * the value should include and up to the last bit of frame_header_obu() and
+	 * excluding the bits generated by byte_alignment(). If EnableFrameOBU == 0,
+	 * the value should include and up to the trailing bit at the end of the frame
+	 * header obu. The size will be used by encoder to calculate the final frame
+	 * header size after bit shifting due to auto segmentation.
+     */
+    uint32_t    size_in_bits_frame_hdr_obu;
+
+    /** \brief Tile Group OBU header */
+    union {
+        struct {
+            /** \brief Corresponds to AV1 syntax element of the same name.
+             *  value range [0..1].
+             */
+            uint8_t     obu_extension_flag              : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name.
+             *  value range [0..1].
+             */
+            uint8_t     obu_has_size_field              : 1;
+            /** \brief Corresponds to AV1 syntax element of the same name.
+             *  value range [0..7].
+             */
+            uint8_t     temporal_id                     : 3;
+            /** \brief Corresponds to AV1 syntax element of the same name.
+             *  value range [0..2].
+             */
+            uint8_t     spatial_id                      : 2;
+            /** \brief Reserved bytes for future use, must be zero. */
+            uint8_t     reserved                        : 1;
+        } bits;
+        uint8_t     value;
+    } tile_group_obu_hdr_info;
+
+    uint8_t     reserved8bits1;
+
+    /** \brief Reserved bytes for future use, must be zero */
+    uint32_t    va_reserved[VA_PADDING_HIGH];
+} VAEncPictureParameterBufferAV1;
+
+
+typedef struct _VAEncTileGroupBufferAV1 {
+    /** \brief Tile group start location.
+     *  The position of the first tile in current tile group
+     *  in raster scan order across the frame
+     *  value range [0..127].
+     */
+    uint8_t  tg_start;
+    /** \brief Tile group end location.
+     *  The position of the last tile in current tile group
+     *  in raster scan order across the frame.
+     *  value range [0..127].
+     */
+    uint8_t  tg_end;
+
+    /** \brief Reserved bytes for future use, must be zero. */
+    uint32_t                va_reserved[VA_PADDING_LOW];
+} VAEncTileGroupBufferAV1;
+
+/**@}*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VA_ENC_AV1_H */
diff --git a/libavcodec/vaapi_encode.c b/libavcodec/vaapi_encode.c
index 7510816..5a5a2e0 100644
--- a/libavcodec/vaapi_encode.c
+++ b/libavcodec/vaapi_encode.c
@@ -314,6 +314,15 @@ static int vaapi_encode_issue(AVCodecContext *avctx,
 
     pic->nb_param_buffers = 0;
 
+    if ((avctx->codec_id == AV_CODEC_ID_AV1) && (pic->type == PICTURE_TYPE_B)
+        && (pic->next->type == PICTURE_TYPE_P)) {
+        pic->tail_data = av_mallocz(MAX_PARAM_BUFFER_SIZE);
+        if (!pic->tail_data) {
+            err = AVERROR(ENOMEM);
+            goto fail;
+        }
+    }
+
     if (pic->type == PICTURE_TYPE_IDR && ctx->codec->init_sequence_params) {
         err = vaapi_encode_make_param_buffer(avctx, pic,
                                              VAEncSequenceParameterBufferType,
@@ -617,6 +626,7 @@ fail_at_end:
     av_freep(&pic->param_buffers);
     av_freep(&pic->slices);
     av_freep(&pic->roi);
+    av_freep(&pic->tail_data);
     av_frame_free(&pic->recon_image);
     av_buffer_unref(&pic->output_buffer_ref);
     pic->output_buffer = VA_INVALID_ID;
@@ -650,7 +660,7 @@ static int vaapi_encode_output(AVCodecContext *avctx,
     for (buf = buf_list; buf; buf = buf->next)
         total_size += buf->size;
 
-    err = ff_get_encode_buffer(avctx, pkt, total_size, 0);
+    err = ff_get_encode_buffer(avctx, pkt, total_size + pic->tail_size, 0);
     ptr = pkt->data;
 
     if (err < 0)
@@ -664,6 +674,9 @@ static int vaapi_encode_output(AVCodecContext *avctx,
         ptr += buf->size;
     }
 
+    if (pic->tail_size)
+        memcpy(ptr, pic->tail_data, pic->tail_size);
+
     if (pic->type == PICTURE_TYPE_IDR)
         pkt->flags |= AV_PKT_FLAG_KEY;
 
@@ -758,12 +771,34 @@ static int vaapi_encode_free(AVCodecContext *avctx,
     av_freep(&pic->priv_data);
     av_freep(&pic->codec_picture_params);
     av_freep(&pic->roi);
+    av_freep(&pic->tail_data);
 
     av_free(pic);
 
     return 0;
 }
 
+int ff_vaapi_encode_get_attributs(AVCodecContext *avctx, VAConfigAttrib *attr)
+{
+    VAAPIEncodeContext *ctx = avctx->priv_data;
+    VAStatus vas;
+
+    vas = vaGetConfigAttributes(ctx->hwctx->display,
+                                ctx->va_profile,
+                                ctx->va_entrypoint,
+                                attr, 1);
+    if (vas != VA_STATUS_SUCCESS) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to query "
+               "config attribute: %d (%s).\n", vas, vaErrorStr(vas));
+        return AVERROR_EXTERNAL;
+    }
+    if (attr->value == VA_ATTRIB_NOT_SUPPORTED)
+        av_log(avctx, AV_LOG_WARNING, "attribute type:%d is not "
+               "supported.\n", attr->type);
+
+    return 0;
+}
+
 static void vaapi_encode_add_ref(AVCodecContext *avctx,
                                  VAAPIEncodePicture *pic,
                                  VAAPIEncodePicture *target,
diff --git a/libavcodec/vaapi_encode.h b/libavcodec/vaapi_encode.h
index b41604a..3d1359c 100644
--- a/libavcodec/vaapi_encode.h
+++ b/libavcodec/vaapi_encode.h
@@ -125,6 +125,9 @@ typedef struct VAAPIEncodePicture {
 
     int          nb_slices;
     VAAPIEncodeSlice *slices;
+
+    size_t tail_size;
+    void  *tail_data;
 } VAAPIEncodePicture;
 
 typedef struct VAAPIEncodeProfile {
@@ -441,6 +444,7 @@ int ff_vaapi_encode_receive_packet(AVCodecContext *avctx, AVPacket *pkt);
 int ff_vaapi_encode_init(AVCodecContext *avctx);
 int ff_vaapi_encode_close(AVCodecContext *avctx);
 
+int ff_vaapi_encode_get_attributs(AVCodecContext *avctx, VAConfigAttrib *attr);
 
 #define VAAPI_ENCODE_COMMON_OPTIONS \
     { "low_power", \
diff --git a/libavcodec/vaapi_encode_av1.c b/libavcodec/vaapi_encode_av1.c
new file mode 100644
index 0000000..c40c6d3
--- /dev/null
+++ b/libavcodec/vaapi_encode_av1.c
@@ -0,0 +1,579 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+
+#include <va/va.h>
+//#include <va/va_enc_av1.h>
+#include "va_private_enc_av1.h"
+
+#include "libavutil/pixdesc.h"
+#include "libavutil/avassert.h"
+#include "libavutil/opt.h"
+#include "internal.h"
+#include "cbs.h"
+#include "cbs_av1.h"
+#include "av1.h"
+#include "vaapi_encode.h"
+
+#define AV1_MAX_QUANT 255
+
+typedef struct VAAPIEncodeAV1Picture {
+    int64_t last_idr_frame;
+    int slot;
+} VAAPIEncodeAV1Picture;
+
+typedef struct VAAPIEncodeAV1Context {
+    VAAPIEncodeContext common;
+    AV1RawOBU sh; /**< sequence header.*/
+    AV1RawOBU fr; /**< frame.*/
+    AV1RawOBU fh; /**< frame header.*/
+    AV1RawOBU th; /**< tile group header.*/
+    CodedBitstreamContext *cbc;
+    CodedBitstreamFragment current_obu;
+    VAConfigAttribValEncAV1 attr;
+    VAConfigAttribValEncAV1Ext1 attr_ext1;
+    VAConfigAttribValEncAV1Ext2 attr_ext2;
+
+    /** user options */
+    int qp;
+
+    size_t sequence_size;
+} VAAPIEncodeAV1Context;
+
+static av_cold int vaapi_encode_av1_configure(AVCodecContext *avctx)
+{
+    VAAPIEncodeAV1Context *priv = avctx->priv_data;
+    int ret;
+    ret = ff_cbs_init(&priv->cbc, AV_CODEC_ID_AV1, avctx);
+    if (ret < 0)
+        return ret;
+
+    return 0;
+}
+
+static int vaapi_encode_av1_add_obu(AVCodecContext *avctx,
+                                    CodedBitstreamFragment *au,
+                                    uint8_t type,
+                                    void *obu_unit)
+{
+    int ret;
+
+    ret = ff_cbs_insert_unit_content(au, -1,
+                                     type, obu_unit, NULL);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to add OBU unit: "
+               "type = %d.\n", type);
+        return ret;
+    }
+
+    return 0;
+}
+
+static int vaapi_encode_av1_write_obu(AVCodecContext *avctx,
+                                      char *data, size_t *data_len,
+                                      CodedBitstreamFragment *au)
+{
+    VAAPIEncodeAV1Context *priv = avctx->priv_data;
+    int ret;
+
+    ret = ff_cbs_write_fragment_data(priv->cbc, au);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to write packed header.\n");
+        return ret;
+    }
+
+    if (*data_len < 8 * au->data_size - au->data_bit_padding) {
+        av_log(avctx, AV_LOG_ERROR, "Access unit too large: "
+               "%zu < %zu.\n", *data_len,
+               8 * au->data_size - au->data_bit_padding);
+        return AVERROR(ENOSPC);
+    }
+
+    memcpy(data, au->data, au->data_size);
+    *data_len = 8 * au->data_size - au->data_bit_padding;
+
+    return 0;
+}
+
+static int vaapi_encode_av1_write_sequence_header(AVCodecContext *avctx,
+                                                  char *data, size_t *data_len)
+{
+    VAAPIEncodeAV1Context *priv = avctx->priv_data;
+    CodedBitstreamFragment *obu = &priv->current_obu;
+    int ret;
+
+    ret = vaapi_encode_av1_add_obu(avctx, obu, AV1_OBU_SEQUENCE_HEADER, &priv->sh);
+    if (ret < 0)
+        goto fail;
+
+    ret = vaapi_encode_av1_write_obu(avctx, data, data_len, obu);
+    if (ret < 0)
+        goto fail;
+
+fail:
+    ff_cbs_fragment_reset(obu);
+    return ret;
+}
+
+static int vaapi_encode_av1_init_sequence_params(AVCodecContext *avctx)
+{
+    VAAPIEncodeContext               *ctx = avctx->priv_data;
+    VAAPIEncodeAV1Context           *priv = avctx->priv_data;
+    AV1RawOBU                        *obu = &priv->sh;
+    AV1RawSequenceHeader              *sh = &obu->obu.sequence_header;
+    VAEncSequenceParameterBufferAV1 *vseq = ctx->codec_sequence_params;
+    const AVPixFmtDescriptor *desc;
+    char data[MAX_PARAM_BUFFER_SIZE];
+
+    memset(obu, 0, sizeof(*obu));
+    priv->sequence_size = 8 * sizeof(data);
+
+    obu->header.obu_type = AV1_OBU_SEQUENCE_HEADER;
+
+    desc = av_pix_fmt_desc_get(priv->common.input_frames->sw_format);
+    av_assert0(desc);
+
+    sh->seq_profile  = avctx->profile;
+    if (!sh->seq_force_screen_content_tools)
+        sh->seq_force_integer_mv = AV1_SELECT_INTEGER_MV;
+    sh->frame_width_bits_minus_1 = av_log2(avctx->width);
+    sh->frame_height_bits_minus_1 = av_log2(avctx->height);
+    sh->max_frame_width_minus_1 = avctx->width - 1;
+    sh->max_frame_height_minus_1 = avctx->height - 1;
+    sh->enable_order_hint = 1;
+    sh->order_hint_bits_minus_1 = av_log2(avctx->gop_size);
+
+    sh->color_config = (AV1RawColorConfig) {
+        .high_bitdepth                  = desc->comp[0].depth == 8 ? 0 : 1,
+        .color_primaries                = avctx->color_primaries,
+        .transfer_characteristics       = avctx->color_trc,
+        .matrix_coefficients            = avctx->colorspace,
+        .color_description_present_flag = (avctx->color_primaries != AVCOL_PRI_UNSPECIFIED ||
+                                           avctx->color_trc       != AVCOL_TRC_UNSPECIFIED ||
+                                           avctx->colorspace      != AVCOL_SPC_UNSPECIFIED),
+        .subsampling_x                  = desc->log2_chroma_w,
+        .subsampling_y                  = desc->log2_chroma_h,
+    };
+
+    vseq->seq_profile             = sh->seq_profile;
+    vseq->order_hint_bits_minus_1 = sh->order_hint_bits_minus_1;
+    vseq->intra_period            = ctx->gop_size;
+    vseq->ip_period               = ctx->b_per_p + 1;
+    vseq->order_hint_bits_minus_1 = sh->order_hint_bits_minus_1;
+
+    vseq->seq_fields.bits.enable_order_hint = sh->enable_order_hint;
+
+    return vaapi_encode_av1_write_sequence_header(avctx, data, &priv->sequence_size);
+}
+
+static int vaapi_encode_av1_init_picture_params(AVCodecContext *avctx,
+                                                VAAPIEncodePicture *pic)
+{
+    VAAPIEncodeContext             *ctx  = avctx->priv_data;
+    VAAPIEncodePicture             *prev = pic->prev;
+    VAAPIEncodeAV1Picture         *hprev = prev ? prev->priv_data : NULL;
+    VAAPIEncodeAV1Context          *priv = avctx->priv_data;
+    VAAPIEncodeAV1Picture          *hpic = pic->priv_data;
+    AV1RawOBU                      *obu  = &priv->fr;
+    AV1RawFrameHeader              *fh   = &obu->obu.frame.header;
+    const AV1RawSequenceHeader     *sh   = &priv->sh.obu.sequence_header;
+    VAEncPictureParameterBufferAV1 *vpic = pic->codec_picture_params;
+    VAAPIEncodeAV1Picture *href0, *href1;
+    int mi_cols, mi_rows, sb_cols, sb_rows;
+    int slot, i;
+    static const int8_t default_loop_filter_ref_deltas[AV1_TOTAL_REFS_PER_FRAME] =
+        { 1, 0, 0, 0, -1, 0, -1, -1 };
+
+    memset(obu, 0, sizeof(*obu));
+    // Todo: add the cols and rows options.
+    pic->nb_slices = 1;
+
+    obu->header.obu_type = AV1_OBU_FRAME;
+
+    /**< Set the data_size with the minimum value of the nummber that caculate by
+    tile size bytes get from driver. */
+    if (priv->attr_ext2.bits.tile_size_bytes_minus1)
+        for (i=0; i <= priv->attr_ext2.bits.tile_size_bytes_minus1; i++)
+            obu->obu.frame.tile_group.tile_data.data_size |= (1 << (i * 7));
+
+    switch (pic->type) {
+    case PICTURE_TYPE_IDR:
+        av_assert0(pic->nb_refs == 0);
+        fh->frame_type = AV1_FRAME_KEY;
+        fh->refresh_frame_flags = 0xff;
+        hpic->slot = 0;
+        hpic->last_idr_frame = pic->display_order;
+        break;
+    case PICTURE_TYPE_P:
+        av_assert0(pic->nb_refs == 1);
+        fh->frame_type = AV1_FRAME_INTER;
+        hpic->last_idr_frame = hprev->last_idr_frame;
+        href0 = pic->refs[0]->priv_data;
+        vpic->ref_frame_ctrl_l0.fields.search_idx0 = 1;
+
+        av_assert0(href0->slot == 0 || href0->slot == 1);
+
+        if (ctx->max_b_depth > 0) {
+            hpic->slot = !href0->slot;
+            fh->refresh_frame_flags = 1 << hpic->slot | 0xfc;
+            for (i=0; i < AV1_NUM_REF_FRAMES; i++) {
+                fh->ref_order_hint[i] = pic->refs[0]->display_order - hpic->last_idr_frame;
+            }
+
+            if (hpic->slot) {
+                for (i=0; i <= AV1_REFS_PER_FRAME; i++)
+                    fh->ref_frame_idx[i] = 0;
+                if (pic->refs[0]->refs[0])
+                    fh->ref_order_hint[1] = pic->refs[0]->refs[0]->display_order - hpic->last_idr_frame;
+            } else {
+                for (i=0; i <= AV1_REFS_PER_FRAME; i++)
+                    fh->ref_frame_idx[i] = 1;
+                fh->primary_ref_frame = 1;
+                if (pic->refs[0]->refs[0])
+                    fh->ref_order_hint[0] = pic->refs[0]->refs[0]->display_order - hpic->last_idr_frame;
+            }
+        } else {
+            hpic->slot = 0;
+            fh->refresh_frame_flags = 0xff;
+            for (i=0; i < AV1_NUM_REF_FRAMES; i++)
+                fh->ref_order_hint[i] = pic->refs[0]->display_order - hpic->last_idr_frame;
+        }
+        break;
+    case PICTURE_TYPE_B:
+        av_assert0(pic->nb_refs == 2);
+        href0 = pic->refs[0]->priv_data;
+        href1 = pic->refs[1]->priv_data;
+        av_assert0(href0->slot < pic->b_depth + 1 &&
+                   href1->slot < pic->b_depth + 1);
+        fh->frame_type = AV1_FRAME_INTER;
+        fh->refresh_frame_flags = 0x0;
+        fh->reference_select = 1;
+        hpic->last_idr_frame = hprev->last_idr_frame;
+        vpic->ref_frame_ctrl_l0.fields.search_idx0 = 1;
+        vpic->ref_frame_ctrl_l1.fields.search_idx0 = 5;
+
+        if (href0->slot) {
+            for (i=0; i < 4; i++) {
+                fh->ref_frame_idx[i] = 1;
+            }
+            for (i=4; i < 7; i++) {
+                fh->ref_frame_idx[i] = 0;
+            }
+            for (i=0; i < AV1_NUM_REF_FRAMES; i++)
+                fh->ref_order_hint[i] = pic->refs[1]->display_order - hpic->last_idr_frame;
+            fh->ref_order_hint[1] = pic->refs[0]->display_order - hpic->last_idr_frame;
+            fh->primary_ref_frame = 1;
+        } else {
+            for (i=0; i < 4; i++) {
+                fh->ref_frame_idx[i] = 0;
+            }
+            for (i=4; i < 7; i++) {
+                fh->ref_frame_idx[i] = 1;
+            }
+
+            for (i=0; i < AV1_NUM_REF_FRAMES; i++) {
+                fh->ref_order_hint[i] = pic->refs[1]->display_order - hpic->last_idr_frame;
+            }
+            fh->ref_order_hint[0] = pic->refs[0]->display_order - hpic->last_idr_frame;
+        }
+        break;
+    default:
+        av_assert0(0 && "invalid picture type");
+    }
+
+    fh->show_frame                = pic->display_order <= pic->encode_order;
+    fh->showable_frame            = fh->frame_type != AV1_FRAME_KEY;
+    fh->frame_width_minus_1       = avctx->width - 1;
+    fh->frame_height_minus_1      = avctx->height - 1;
+    fh->render_width_minus_1      = fh->frame_width_minus_1;
+    fh->render_height_minus_1     = fh->frame_height_minus_1;
+    fh->order_hint                = pic->display_order - hpic->last_idr_frame;
+    fh->base_q_idx                = priv->qp;
+    fh->tile_rows                 = 1;
+    fh->tile_cols                 = 1;
+    fh->uniform_tile_spacing_flag = 1;
+
+
+    if (priv->attr_ext2.bits.tx_mode_support)
+        fh->tx_mode = priv->attr_ext2.bits.tx_mode_support;
+
+    mi_cols = 2 * ((avctx->width  + 7) >> 3);
+    mi_rows = 2 * ((avctx->height + 7) >> 3);
+    sb_cols = sh->use_128x128_superblock ? ((mi_cols + 31) >> 5)
+                                         : ((mi_cols + 15) >> 4);
+    sb_rows = sh->use_128x128_superblock ? ((mi_rows + 31) >> 5)
+                                         : ((mi_rows + 15) >> 4);
+
+    fh->width_in_sbs_minus_1[0]  = sb_cols -1;
+    fh->height_in_sbs_minus_1[0] = sb_rows -1;
+
+    vpic->width_in_sbs_minus_1[0]  = sb_cols -1;
+    vpic->height_in_sbs_minus_1[0] = sb_rows -1;
+
+    memcpy(fh->loop_filter_ref_deltas, default_loop_filter_ref_deltas,
+           AV1_TOTAL_REFS_PER_FRAME * sizeof(int8_t));
+
+    if (fh->frame_type == AV1_FRAME_KEY) {
+        fh->error_resilient_mode = 1;
+        fh->refresh_frame_flags = (1 << AV1_NUM_REF_FRAMES) - 1;
+    }
+
+    if (fh->frame_type == AV1_FRAME_KEY || fh->error_resilient_mode)
+        fh->primary_ref_frame = AV1_PRIMARY_REF_NONE;
+
+    vpic->base_qindex          = fh->base_q_idx;
+    vpic->frame_width_minus_1  = fh->frame_width_minus_1;
+    vpic->frame_height_minus_1 = fh->frame_height_minus_1;
+    vpic->primary_ref_frame    = fh->primary_ref_frame;
+    vpic->reconstructed_frame  = pic->recon_surface;
+    vpic->coded_buf            = pic->output_buffer;
+    vpic->tile_cols            = fh->tile_rows;
+    vpic->tile_rows            = fh->tile_cols;
+    vpic->order_hint           = fh->order_hint;
+
+    vpic->picture_flags.bits.enable_frame_obu     = 1;
+    vpic->picture_flags.bits.frame_type           = fh->frame_type;
+    vpic->picture_flags.bits.reduced_tx_set       = fh->reduced_tx_set;
+    vpic->picture_flags.bits.error_resilient_mode = fh->error_resilient_mode;
+
+    vpic->mode_control_flags.bits.reference_mode = fh->reference_select;
+    vpic->mode_control_flags.bits.tx_mode = fh->tx_mode;
+
+    // set reference.
+    for (i = 0; i < AV1_REFS_PER_FRAME; i++)
+        vpic->ref_frame_idx[i] = fh->ref_frame_idx[i];
+
+    for (i = 0; i < FF_ARRAY_ELEMS(vpic->reference_frames); i++)
+        vpic->reference_frames[i] = VA_INVALID_SURFACE;
+    for (i = 0; i < pic->nb_refs; i++) {
+        VAAPIEncodePicture *ref_pic = pic->refs[i];
+
+        slot = ((VAAPIEncodeAV1Picture*)ref_pic->priv_data)->slot;
+        av_assert0(vpic->reference_frames[slot] == VA_INVALID_SURFACE);
+
+        vpic->reference_frames[slot] = ref_pic->recon_surface;
+    }
+
+    vpic->byte_offset_frame_hdr_obu_size = (((pic->type == PICTURE_TYPE_IDR) ?
+                                            priv->sequence_size/8 : 0) +
+                                            (obu->header.obu_extension_flag ?
+                                            2 : 1));
+    return 0;
+}
+
+static int vaapi_encode_av1_init_slice_params(AVCodecContext *avctx,
+                                               VAAPIEncodePicture *pic,
+                                               VAAPIEncodeSlice *slice)
+{
+    VAAPIEncodeAV1Context          *priv = avctx->priv_data;
+    AV1RawOBU                      *obu = &priv->th;
+    AV1RawTileGroup                *th = &obu->obu.tile_group;
+    VAEncTileGroupBufferAV1        *vslice = slice->codec_slice_params;
+
+    obu->header.obu_type = AV1_OBU_TILE_GROUP;
+
+    th->tile_start_and_end_present_flag = 0;
+    // Init tile group info.
+    vslice->tg_start = 0;
+    vslice->tg_end = 0;
+
+    return 0;
+}
+
+
+static int vaapi_encode_av1_write_picture_header(AVCodecContext *avctx,
+                                                 VAAPIEncodePicture *pic,
+                                                 char *data, size_t *data_len)
+{
+    VAAPIEncodeAV1Context *priv = avctx->priv_data;
+    CodedBitstreamFragment *obu = &priv->current_obu;
+    AV1RawOBU           *fh_obu = &priv->fh;
+    AV1RawFrameHeader      *fh  = &fh_obu->obu.frame_header;
+    VAAPIEncodeAV1Picture *href0;
+    int ret;
+
+    pic->tail_size = 0;
+
+    // Pack repeat frame header.
+    if ((pic->type == PICTURE_TYPE_B) && (pic->next->type == PICTURE_TYPE_P)) {
+        href0 = pic->refs[0]->priv_data;
+        memset(obu, 0, sizeof(*obu));
+        pic->tail_size = MAX_PARAM_BUFFER_SIZE;
+        fh_obu->header.obu_type = AV1_OBU_FRAME_HEADER;
+        fh->show_existing_frame = 1;
+        fh->frame_to_show_map_idx = href0->slot == 0;
+        fh->frame_type = AV1_FRAME_INTER;
+        fh->frame_width_minus_1 = avctx->width - 1;
+        fh->frame_height_minus_1 = avctx->height - 1;
+        fh->render_width_minus_1 = fh->frame_width_minus_1;
+        fh->render_height_minus_1 = fh->frame_height_minus_1;
+        ret = vaapi_encode_av1_add_obu(avctx, obu, AV1_OBU_FRAME_HEADER, &priv->fh);
+        if (ret < 0)
+            goto end;
+
+        ret = vaapi_encode_av1_write_obu(avctx, pic->tail_data, &pic->tail_size, obu);
+        if (ret < 0)
+            goto end;
+
+        pic->tail_size /= 8;
+
+        ff_cbs_fragment_reset(obu);
+    }
+
+    ret = vaapi_encode_av1_add_obu(avctx, obu, AV1_OBU_FRAME, &priv->fr);
+    if (ret < 0)
+        goto end;
+
+    ret = vaapi_encode_av1_write_obu(avctx, data , data_len, obu);
+    if (ret < 0)
+        goto end;
+
+end:
+    ff_cbs_fragment_reset(obu);
+    return ret;
+}
+
+static const VAAPIEncodeProfile vaapi_encode_av1_profiles[] = {
+    { FF_PROFILE_AV1_MAIN, 8, 3, 1, 1, VAProfileAV1Profile0 },
+    { FF_PROFILE_UNKNOWN }
+};
+
+static const VAAPIEncodeType vaapi_encode_type_av1 = {
+    .profiles        = vaapi_encode_av1_profiles,
+    .flags           = FLAG_CONSTANT_QUALITY_ONLY |
+                       FLAG_B_PICTURES |
+                       FLAG_B_PICTURE_REFERENCES,
+    .default_quality = 25,
+    .configure       = &vaapi_encode_av1_configure,
+
+    .sequence_header_type  = VAEncPackedHeaderSequence,
+    .sequence_params_size  = sizeof(VAEncSequenceParameterBufferAV1),
+    .init_sequence_params  = &vaapi_encode_av1_init_sequence_params,
+    .write_sequence_header = &vaapi_encode_av1_write_sequence_header,
+
+    .picture_priv_data_size = sizeof(VAAPIEncodeAV1Picture),
+    .picture_header_type    = VAEncPackedHeaderPicture,
+    .picture_params_size    = sizeof(VAEncPictureParameterBufferAV1),
+    .init_picture_params    = &vaapi_encode_av1_init_picture_params,
+    .write_picture_header   = &vaapi_encode_av1_write_picture_header,
+
+    .slice_params_size = sizeof(VAEncTileGroupBufferAV1),
+    .init_slice_params = &vaapi_encode_av1_init_slice_params,
+};
+
+static av_cold int vaapi_encode_av1_init(AVCodecContext *avctx)
+{
+    VAAPIEncodeContext      *ctx = avctx->priv_data;
+    VAAPIEncodeAV1Context  *priv = avctx->priv_data;
+    VAConfigAttrib attr;
+    int ret;
+
+    ctx->codec = &vaapi_encode_type_av1;
+
+    ctx->surface_width  = FFALIGN(avctx->width,  16);
+    ctx->surface_height = FFALIGN(avctx->height, 16);
+
+    ctx->desired_packed_headers =
+        VA_ENC_PACKED_HEADER_SEQUENCE |
+        VA_ENC_PACKED_HEADER_PICTURE;
+        //VA_ENC_PACKED_HEADER_SLICE;
+
+    ret = ff_vaapi_encode_init(avctx);
+    if (ret < 0)
+        return ret;
+
+    attr.type = VAConfigAttribEncAV1;
+    ret = ff_vaapi_encode_get_attributs(avctx, &attr);
+    if (ret < 0)
+        return ret;
+    if (attr.value == VA_ATTRIB_NOT_SUPPORTED)
+        priv->attr.value = 0;
+    else
+        priv->attr.value = attr.value;
+
+    attr.type = VAConfigAttribEncAV1Ext1;
+    ret = ff_vaapi_encode_get_attributs(avctx, &attr);
+    if (ret < 0)
+        return ret;
+    if (attr.value == VA_ATTRIB_NOT_SUPPORTED)
+        priv->attr_ext1.value = 0;
+    else
+        priv->attr_ext1.value = attr.value;
+
+    attr.type = VAConfigAttribEncAV1Ext2;
+    ret = ff_vaapi_encode_get_attributs(avctx, &attr);
+    if (ret < 0)
+        return ret;
+    if (attr.value == VA_ATTRIB_NOT_SUPPORTED)
+        priv->attr_ext2.value = 0;
+    else
+        priv->attr_ext2.value = attr.value;
+
+    return 0;
+}
+
+static av_cold int vaapi_encode_av1_close(AVCodecContext *avctx)
+{
+    VAAPIEncodeAV1Context *priv = avctx->priv_data;
+
+    ff_cbs_fragment_free(&priv->current_obu);
+    ff_cbs_close(&priv->cbc);
+
+    return ff_vaapi_encode_close(avctx);
+}
+
+#define OFFSET(x) offsetof(VAAPIEncodeAV1Context, x)
+#define FLAGS (AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM)
+
+static const AVOption vaapi_encode_av1_options[] = {
+    VAAPI_ENCODE_COMMON_OPTIONS,
+    VAAPI_ENCODE_RC_OPTIONS,
+
+    { "qp", "Constant QP (for P-frames; scaled by qfactor/qoffset for I/B)",
+      OFFSET(qp), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 255, FLAGS },
+
+    { NULL },
+};
+
+static const AVClass vaapi_encode_av1_class = {
+    .class_name = "av1_vaapi",
+    .item_name  = av_default_item_name,
+    .option     = vaapi_encode_av1_options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+AVCodec ff_av1_vaapi_encoder = {
+    .name           = "av1_vaapi",
+    .long_name      = NULL_IF_CONFIG_SMALL("AV1 (VAAPI)"),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_AV1,
+    .priv_data_size = sizeof(VAAPIEncodeAV1Context),
+    .init           = &vaapi_encode_av1_init,
+    .receive_packet = &ff_vaapi_encode_receive_packet,
+    .close          = &vaapi_encode_av1_close,
+    .priv_class     = &vaapi_encode_av1_class,
+    .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    //.defaults       = vaapi_encode_av1_defaults,
+    .pix_fmts = (const enum AVPixelFormat[]) {
+        AV_PIX_FMT_VAAPI,
+        AV_PIX_FMT_NONE,
+    },
+    .hw_configs     = ff_vaapi_encode_hw_configs,
+    .wrapper_name   = "vaapi",
+};
-- 
1.8.3.1

