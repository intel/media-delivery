From fcd35d3c1d001fc63291d72d27dd7e2090fb067e Mon Sep 17 00:00:00 2001
From: "Chen,Wenbin" <wenbin.chen@intel.com>
Date: Thu, 8 Apr 2021 13:09:47 +0800
Subject: [PATCH 11/13] libavcodec/qsvenc_av1: add av1_qsv encoder

Don't enable av1_qsv_encoder if using libmfx or an older version of
libvpl (Haihao)

sample command:
ffmpeg -f rawvideo -pix_fmt yuv420p -s 1920x1080 -i input.yuv -c:v
av1_qsv -low_power 1 -async_depth 1 -q 50 output.ivf

Signed-off-by: Wenbin Chen <wenbin.chen@intel.com>
Signed-off-by: Haihao Xiang <haihao.xiang@intel.com>
---
 configure               |   4 ++
 libavcodec/Makefile     |   2 +
 libavcodec/allcodecs.c  |   1 +
 libavcodec/qsvenc.c     | 119 +++++++++++++++++++++++++++++++++++++++-
 libavcodec/qsvenc.h     |   9 ++-
 libavcodec/qsvenc_av1.c | 105 +++++++++++++++++++++++++++++++++++
 6 files changed, 236 insertions(+), 4 deletions(-)
 create mode 100644 libavcodec/qsvenc_av1.c

diff --git a/configure b/configure
index e9d2564819..4a0d7b7d6a 100755
--- a/configure
+++ b/configure
@@ -3191,6 +3191,8 @@ vp9_qsv_encoder_select="qsvenc"
 vp9_v4l2m2m_decoder_deps="v4l2_m2m vp9_v4l2_m2m"
 wmv3_crystalhd_decoder_select="crystalhd"
 av1_qsv_decoder_select="qsvdec"
+av1_qsv_encoder_select="qsvenc"
+av1_qsv_encoder_deps="libvpl MFX_EXTBUFF_AV1_BITSTREAM_PARAM"
 
 # parsers
 aac_parser_select="adts_header"
@@ -6456,6 +6458,8 @@ elif enabled libvpl; then
         warn "build FFmpeg against oneVPL 2.2+, OPAQUE memory, multi-frame encode, user plugins\n"\
              "and LA_EXT rate control mode in FFmpeg QSV won't be supported." ||
             die "ERROR: libvpl >= 2.2 not found"
+
+    check_cc MFX_EXTBUFF_AV1_BITSTREAM_PARAM "mfxdefs.h mfxstructures.h" "MFX_EXTBUFF_AV1_BITSTREAM_PARAM"
 fi
 
 if enabled libmfx; then
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 8012b69f61..d9287e16d5 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -229,6 +229,8 @@ OBJS-$(CONFIG_AURA_DECODER)            += cyuv.o
 OBJS-$(CONFIG_AURA2_DECODER)           += aura.o
 OBJS-$(CONFIG_AV1_DECODER)             += av1dec.o
 OBJS-$(CONFIG_AV1_CUVID_DECODER)       += cuviddec.o
+OBJS-$(CONFIG_AV1_QSV_DECODER)         += qsvdec.o
+OBJS-$(CONFIG_AV1_QSV_ENCODER)         += qsvenc_av1.o
 OBJS-$(CONFIG_AVRN_DECODER)            += avrndec.o
 OBJS-$(CONFIG_AVRP_DECODER)            += r210dec.o
 OBJS-$(CONFIG_AVRP_ENCODER)            += r210enc.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index c42aba140d..a7555e1e8b 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -800,6 +800,7 @@ extern const AVCodec ff_libaom_av1_decoder;
 extern const AVCodec ff_av1_decoder;
 extern const AVCodec ff_av1_cuvid_decoder;
 extern const AVCodec ff_av1_qsv_decoder;
+extern const AVCodec ff_av1_qsv_encoder;
 extern const AVCodec ff_libopenh264_encoder;
 extern const AVCodec ff_libopenh264_decoder;
 extern const AVCodec ff_h264_amf_encoder;
diff --git a/libavcodec/qsvenc.c b/libavcodec/qsvenc.c
index 546efd9668..69712a8953 100644
--- a/libavcodec/qsvenc.c
+++ b/libavcodec/qsvenc.c
@@ -629,9 +629,16 @@ static int init_video_param(AVCodecContext *avctx, QSVEncContext *q)
     case MFX_RATECONTROL_CQP:
         quant = avctx->global_quality / FF_QP2LAMBDA;
 
-        q->param.mfx.QPI = av_clip(quant * fabs(avctx->i_quant_factor) + avctx->i_quant_offset, 0, 51);
-        q->param.mfx.QPP = av_clip(quant, 0, 51);
-        q->param.mfx.QPB = av_clip(quant * fabs(avctx->b_quant_factor) + avctx->b_quant_offset, 0, 51);
+        if (avctx->codec_id == AV_CODEC_ID_AV1) {
+            q->param.mfx.QPI = av_clip(quant * fabs(avctx->i_quant_factor) + avctx->i_quant_offset, 0, 255);
+            q->param.mfx.QPP = av_clip(quant, 0, 255);
+            q->param.mfx.QPB = av_clip(quant * fabs(avctx->b_quant_factor) + avctx->b_quant_offset, 0, 255);
+        } else {
+            q->param.mfx.QPI = av_clip(quant * fabs(avctx->i_quant_factor) + avctx->i_quant_offset, 0, 51);
+            q->param.mfx.QPP = av_clip(quant, 0, 51);
+            q->param.mfx.QPB = av_clip(quant * fabs(avctx->b_quant_factor) + avctx->b_quant_offset, 0, 51);
+        }
+
 
         break;
 #if QSV_HAVE_AVBR
@@ -797,6 +804,21 @@ static int init_video_param(AVCodecContext *avctx, QSVEncContext *q)
     }
 #endif
 
+#if QSV_HAVE_EXT_AV1_PARAM
+    if (avctx->codec_id == AV_CODEC_ID_AV1) {
+        q->extav1tileparam.Header.BufferId = MFX_EXTBUFF_AV1_TILE_PARAM;
+        q->extav1tileparam.Header.BufferSz = sizeof(q->extav1tileparam);
+        q->extav1tileparam.NumTileColumns  = q->tile_cols;
+        q->extav1tileparam.NumTileRows     = q->tile_rows;
+        q->extparam_internal[q->nb_extparam_internal++] = (mfxExtBuffer *)&q->extav1tileparam;
+
+        q->extav1bsparam.Header.BufferId = MFX_EXTBUFF_AV1_BITSTREAM_PARAM;
+        q->extav1bsparam.Header.BufferSz = sizeof(q->extav1bsparam);
+        q->extav1bsparam.WriteIVFHeaders = MFX_CODINGOPTION_OFF;
+        q->extparam_internal[q->nb_extparam_internal++] = (mfxExtBuffer *)&q->extav1bsparam;
+    }
+#endif
+
 #if QSV_HAVE_EXT_HEVC_TILES
     if (avctx->codec_id == AV_CODEC_ID_HEVC) {
         q->exthevctiles.Header.BufferId = MFX_EXTBUFF_HEVC_TILES;
@@ -902,6 +924,77 @@ static int qsv_retrieve_enc_vp9_params(AVCodecContext *avctx, QSVEncContext *q)
     return 0;
 }
 
+static int qsv_retrieve_enc_av1_params(AVCodecContext *avctx, QSVEncContext *q)
+{
+    int ret = 0;
+#if QSV_HAVE_EXT_AV1_PARAM
+    mfxExtAV1TileParam av1_extend_tile_buf = {
+         .Header.BufferId = MFX_EXTBUFF_AV1_TILE_PARAM,
+         .Header.BufferSz = sizeof(av1_extend_tile_buf),
+    };
+#endif
+
+#if QSV_HAVE_CO2
+    mfxExtCodingOption2 co2 = {
+        .Header.BufferId = MFX_EXTBUFF_CODING_OPTION2,
+        .Header.BufferSz = sizeof(co2),
+    };
+#endif
+
+#if QSV_HAVE_CO3
+    mfxExtCodingOption3 co3 = {
+        .Header.BufferId = MFX_EXTBUFF_CODING_OPTION3,
+        .Header.BufferSz = sizeof(co3),
+    };
+#endif
+
+    mfxExtBuffer *ext_buffers[] = {
+#if QSV_HAVE_EXT_AV1_PARAM
+        (mfxExtBuffer*)&av1_extend_tile_buf,
+#endif
+#if QSV_HAVE_CO2
+        (mfxExtBuffer*)&co2,
+#endif
+#if QSV_HAVE_CO3
+        (mfxExtBuffer*)&co3,
+#endif
+    };
+
+    q->param.ExtParam    = ext_buffers;
+    q->param.NumExtParam = FF_ARRAY_ELEMS(ext_buffers);
+
+    ret = MFXVideoENCODE_GetVideoParam(q->session, &q->param);
+    if (ret < 0)
+        return ff_qsv_print_error(avctx, ret,
+                                  "Error calling GetVideoParam");
+
+    q->packet_size = q->param.mfx.BufferSizeInKB * q->param.mfx.BRCParamMultiplier * 1000;
+
+    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
+        const AVBitStreamFilter *filter = av_bsf_get_by_name("extract_extradata");
+        int ret;
+
+        if (!filter) {
+            av_log(avctx, AV_LOG_ERROR, "extract_extradata bitstream filter "
+                   "not found. This is a bug, please report it.\n");
+            return AVERROR_BUG;
+        }
+        ret = av_bsf_alloc(filter, &q->bsf);
+        if (ret < 0)
+            return ret;
+
+        ret = avcodec_parameters_from_context(q->bsf->par_in, avctx);
+        if (ret < 0)
+           return ret;
+
+        ret = av_bsf_init(q->bsf);
+        if (ret < 0)
+           return ret;
+    }
+
+    return 0;
+}
+
 static int qsv_retrieve_enc_params(AVCodecContext *avctx, QSVEncContext *q)
 {
     AVCPBProperties *cpb_props;
@@ -1259,6 +1352,9 @@ int ff_qsv_enc_init(AVCodecContext *avctx, QSVEncContext *q)
     case AV_CODEC_ID_VP9:
         ret = qsv_retrieve_enc_vp9_params(avctx, q);
         break;
+    case AV_CODEC_ID_AV1:
+        ret = qsv_retrieve_enc_av1_params(avctx, q);
+        break;
     default:
         ret = qsv_retrieve_enc_params(avctx, q);
         break;
@@ -1611,6 +1707,22 @@ int ff_qsv_encode(AVCodecContext *avctx, QSVEncContext *q,
 
         av_packet_move_ref(pkt, &new_pkt);
 
+        if (avctx->codec_id == AV_CODEC_ID_AV1 && avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
+            ret = av_bsf_send_packet(q->bsf, pkt);
+            if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "extract_extradata filter "
+                    "failed to send input packet\n");
+                return ret;
+            }
+
+            ret = av_bsf_receive_packet(q->bsf, pkt);
+            if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "extract_extradata filter "
+                    "failed to receive output packet\n");
+                return ret;
+            }
+        }
+
         *got_packet = 1;
     }
 
@@ -1661,6 +1773,7 @@ int ff_qsv_enc_close(AVCodecContext *avctx, QSVEncContext *q)
 #endif
 
     av_freep(&q->extparam);
+    av_bsf_free(&q->bsf);
 
     return 0;
 }
diff --git a/libavcodec/qsvenc.h b/libavcodec/qsvenc.h
index 7a7eaea156..f4a485c389 100644
--- a/libavcodec/qsvenc.h
+++ b/libavcodec/qsvenc.h
@@ -44,6 +44,7 @@
 
 #define QSV_HAVE_EXT_HEVC_TILES QSV_VERSION_ATLEAST(1, 13)
 #define QSV_HAVE_EXT_VP9_PARAM QSV_VERSION_ATLEAST(1, 26)
+#define QSV_HAVE_EXT_AV1_PARAM QSV_VERSION_ATLEAST(2, 5)
 
 #define QSV_HAVE_TRELLIS QSV_VERSION_ATLEAST(1, 8)
 #define QSV_HAVE_MAX_SLICE_SIZE QSV_VERSION_ATLEAST(1, 9)
@@ -137,6 +138,10 @@ typedef struct QSVEncContext {
 #if QSV_HAVE_EXT_VP9_PARAM
     mfxExtVP9Param  extvp9param;
 #endif
+#if QSV_HAVE_EXT_AV1_PARAM
+    mfxExtAV1TileParam extav1tileparam;
+    mfxExtAV1BitstreamParam extav1bsparam;
+#endif
 
 #if QSV_HAVE_OPAQUE
     mfxExtOpaqueSurfaceAlloc opaque_alloc;
@@ -146,7 +151,7 @@ typedef struct QSVEncContext {
 
     mfxExtVideoSignalInfo extvsi;
 
-    mfxExtBuffer  *extparam_internal[3 + QSV_HAVE_CO2 + QSV_HAVE_CO3 + (QSV_HAVE_MF * 2)];
+    mfxExtBuffer  *extparam_internal[3 + QSV_HAVE_CO2 + QSV_HAVE_CO3 + (QSV_HAVE_MF * 2)+QSV_HAVE_EXT_AV1_PARAM*2];
     int         nb_extparam_internal;
 
     mfxExtBuffer **extparam;
@@ -208,6 +213,8 @@ typedef struct QSVEncContext {
     char *load_plugins;
     SetEncodeCtrlCB *set_encode_ctrl_cb;
     int forced_idr;
+
+    AVBSFContext *bsf;
 } QSVEncContext;
 
 int ff_qsv_enc_init(AVCodecContext *avctx, QSVEncContext *q);
diff --git a/libavcodec/qsvenc_av1.c b/libavcodec/qsvenc_av1.c
new file mode 100644
index 0000000000..17528beafe
--- /dev/null
+++ b/libavcodec/qsvenc_av1.c
@@ -0,0 +1,105 @@
+/*
+ * Intel MediaSDK QSV based AV1 encoder
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include <mfxvideo.h>
+
+#include "libavutil/common.h"
+#include "libavutil/opt.h"
+
+#include "avcodec.h"
+#include "internal.h"
+#include "qsv.h"
+#include "qsvenc.h"
+
+typedef struct QSVAV1EncContext {
+    AVClass *class;
+    QSVEncContext qsv;
+    int load_plugin;
+} QSVAV1EncContext;
+
+static av_cold int qsv_enc_init(AVCodecContext *avctx)
+{
+    QSVAV1EncContext *q = avctx->priv_data;
+
+    return ff_qsv_enc_init(avctx, &q->qsv);
+}
+
+static int qsv_enc_frame(AVCodecContext *avctx, AVPacket *pkt,
+                         const AVFrame *frame, int *got_packet)
+{
+    QSVAV1EncContext *q = avctx->priv_data;
+
+    return ff_qsv_encode(avctx, &q->qsv, pkt, frame, got_packet);
+}
+
+static av_cold int qsv_enc_close(AVCodecContext *avctx)
+{
+    QSVAV1EncContext *q = avctx->priv_data;
+
+    return ff_qsv_enc_close(avctx, &q->qsv);
+}
+
+#define OFFSET(x) offsetof(QSVAV1EncContext, x)
+#define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+static const AVOption options[] = {
+    QSV_COMMON_OPTS
+    { "profile", NULL, OFFSET(qsv.profile), AV_OPT_TYPE_INT, { .i64 = MFX_PROFILE_UNKNOWN }, 0, INT_MAX, VE, "profile" },
+        { "unknown" , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MFX_PROFILE_UNKNOWN      }, INT_MIN, INT_MAX,     VE, "profile" },
+        { "main"    , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MFX_PROFILE_AV1_MAIN     }, INT_MIN, INT_MAX,     VE, "profile" },
+    { "tile_cols",  "Number of columns for tiled encoding",   OFFSET(qsv.tile_cols),    AV_OPT_TYPE_INT, { .i64 = 0 }, 0, UINT16_MAX, VE },
+    { "tile_rows",  "Number of rows for tiled encoding",      OFFSET(qsv.tile_rows),    AV_OPT_TYPE_INT, { .i64 = 0 }, 0, UINT16_MAX, VE },
+    { NULL },
+};
+
+static const AVClass class = {
+    .class_name = "av1_qsv encoder",
+    .item_name  = av_default_item_name,
+    .option     = options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+static const AVCodecDefault qsv_enc_defaults[] = {
+    { NULL },
+};
+
+AVCodec ff_av1_qsv_encoder = {
+    .name           = "av1_qsv",
+    .long_name      = NULL_IF_CONFIG_SMALL("AV1 (Intel Quick Sync Video acceleration)"),
+    .priv_data_size = sizeof(QSVAV1EncContext),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_AV1,
+    .init           = qsv_enc_init,
+    .encode2        = qsv_enc_frame,
+    .close          = qsv_enc_close,
+    .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HYBRID,
+    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_NV12,
+                                                    AV_PIX_FMT_P010,
+                                                    AV_PIX_FMT_QSV,
+                                                    AV_PIX_FMT_NONE },
+    .priv_class     = &class,
+    .defaults       = qsv_enc_defaults,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .wrapper_name   = "qsv",
+    .hw_configs     = ff_qsv_enc_hw_configs,
+};
-- 
2.25.1

